    /// Simulates integrating logic into a Cargo build script.
        println!("Simulating integration into Cargo build script: `{}`", self.name);
./crates/layer1_physical/ragit-core/src/grand_plan/toolchain_augmentation/build_script_integration/build_script_integration_structs.rs
    pub struct CustomCargoCommand {
impl CustomCargoCommand {
        CustomCargoCommand {
    /// Simulates registering a custom `cargo` command.
        println!("Simulating registration of custom cargo command: `cargo {}`", self.name);
        // In a real scenario, this would involve creating a binary named `cargo-name`
        // in a directory on the user's PATH, or using a Cargo plugin system.
pub fn get_grand_plan_cargo_commands() -> Vec<CustomCargoCommand> {
        CustomCargoCommand::new(
        CustomCargoCommand::new(
        CustomCargoCommand::new(
./crates/layer1_physical/ragit-core/src/grand_plan/toolchain_augmentation/custom_cargo_commands/custom_cargo_commands_structs.rs
pub mod custom_cargo_commands_structs;
./crates/layer1_physical/ragit-core/src/grand_plan/toolchain_augmentation/custom_cargo_commands/mod.rs
pub mod custom_cargo_commands;
./crates/layer1_physical/ragit-core/src/grand_plan/toolchain_augmentation/mod.rs
pub const VERSION: &str = env!("CARGO_PKG_VERSION");
./crates/layer3_network/ragit-utils/src/lib.rs
            ragit_version: env!("CARGO_PKG_VERSION").to_string(),
./crates/layer3_network/ragit-index-types/src/index_struct.rs
        let mut path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
./crates/layer3_network/solfunmeme_extractor/src/tests.rs
// cargo run --release > fsm.rs; mv fsm.rs src/fsm.rs; cargo test --release -- --nocapture
./crates/layer6_presentation/korean/src/generator.rs
    println!("ragit version {}", env!("CARGO_PKG_VERSION"));
./crates/layer7_application/ragit-commands/src/commands/version.rs
            let mut cmd = Command::new("cargo");
                anyhow::bail!("cargo run --package ragit-build-index-worker-single-file failed with status: {}", status);
            let mut cmd = Command::new("cargo");
./crates/layer7_application/ragit-commands/src/main.rs
pub struct CargoPackageFileSource {
impl FileSource for CargoPackageFileSource {
        memory_monitor.verbose(&format!("CargoPackageFileSource: Getting files for package: {}", self.package_name));
        memory_monitor.verbose(&format!("CargoPackageFileSource: Package path: {:?}", package_path));
        memory_monitor.verbose(&format!("CargoPackageFileSource: Glob pattern: {}", pattern));
                        memory_monitor.verbose(&format!("CargoPackageFileSource: Found file: {}", path_str));
                    memory_monitor.verbose(&format!("CargoPackageFileSource: Error reading glob entry: {}", e));
        memory_monitor.verbose(&format!("CargoPackageFileSource: Found {} files.", files.len()));
./crates/layer7_application/commands/ragit-command-bootstrap/src/file_source.rs
    let mut cmd = Command::new("cargo");
        anyhow::bail!("cargo run --package ragit-build-index-worker-single-file failed with status: {}", output.status);
./crates/layer7_application/commands/ragit-command-bootstrap/src/bootstrap_command.rs
    let output = Command::new("cargo")
    let output = Command::new("cargo")
./crates/layer7_application/commands/ragit-command-bootstrap/src/bootstrap_commands/self_improvement/run_self_improvement_loop.rs
    if let Some((v1, v2)) = index.migrate(env!("CARGO_PKG_VERSION").to_string())? {
./crates/layer7_application/commands/ragit-command-migrate/src/lib.rs
    println!("ragit version {}", env!("CARGO_PKG_VERSION"));
./crates/layer7_application/commands/ragit-command-version/src/lib.rs
pub struct CargoPackageFileSource {
impl FileSource for CargoPackageFileSource {
        println!("CargoPackageFileSource: Found {} files.", files.len());
./crates/layer7_application/ragit-build-index-worker-single-file/src/bootstrap_commands/file_source.rs
use super::file_source::{FileSource, CargoPackageFileSource, GlobFileSource};
        Some("cargo-toml") => {
            memory_monitor.lock().unwrap().verbose("Using GlobFileSource for Cargo.toml files.");
                patterns: vec!["**/Cargo.toml".to_string()],
            memory_monitor.lock().unwrap().verbose("Using CargoPackageFileSource.");
            Box::new(CargoPackageFileSource {
    memory_monitor.lock().unwrap().verbose(&format!("CargoPackageFileSource: Found {} files.", files_to_add.len()));
./crates/layer7_application/ragit-build-index-worker-single-file/src/bootstrap_commands/add_bootstrap_files.rs
    #[clap(long, value_parser = ["all", "cargo-toml"])]
./crates/layer7_application/ragit-build-index-worker-single-file/src/args/bootstrap_args.rs
    let temp_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("target").join("debug");
./crates/layer7_application/ragit-build-index-worker-single-file/tests/chunk_serialization_test.rs
            if let Ok(Some((v1, v2))) = Index::migrate(&root_dir.to_string_lossy().into_owned(), env!("CARGO_PKG_VERSION").to_string()) {
./src/commands/check_command.rs
// |                             | Cargo.toml  | this constant  |
./src/lib.rs
//! Run `cargo test` to verify flow behavior and mathematical consistency.
./vendor/meta-introspector/bootstrap/stage0/src/lib.rs
//! Run `cargo test` to verify flow behavior and mathematical consistency.
./vendor/meta-introspector/solfunmeme-dioxus/bootstrap/stage0/src/lib.rs
    println!("cargo:rerun-if-changed=components.manifest");
./vendor/meta-introspector/solfunmeme-dioxus/crates/bootstrap/stage0/build.rs
            "Cargo.toml".to_string(),
            "Cargo Configuration".to_string(),
                    "Cargo.toml".to_string(),
                    document: "Cargo.toml".to_string(),
            "Cargo.toml",
            "Cargo.toml",
            "Cargo.toml",
            "Cargo.toml",
./vendor/meta-introspector/solfunmeme-dioxus/crates/doc_cross_references/src/documentation_index.rs
        let mut path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
./vendor/meta-introspector/solfunmeme-dioxus/crates/solfunmeme_extractor/src/tests.rs
    let lean4_ontology_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
    let emoji_ontology_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
./vendor/meta-introspector/solfunmeme-dioxus/crates/solfunmeme_tarot/tests/integration_test.rs
#[folder = "../../.."] // Relative to crates/solfunmeme_tools/Cargo.toml
./vendor/meta-introspector/solfunmeme-dioxus/crates/solfunmeme_tools/src/assets.rs
    let mut indexer_command = Command::new("cargo");
        let mut prepare_sources_command = Command::new("cargo");
./vendor/meta-introspector/solfunmeme-dioxus/crates/solfunmeme_tools/src/bin/full_indexer_cli.rs
// Cargo.toml
./vendor/meta-introspector/solfunmeme-dioxus/src/model/memes.rs
// // Cargo.toml
./vendor/meta-introspector/solfunmeme-dioxus/src/playground/solfunmeme.rs
    /// async fn cargo_toml() -> Result<Response, (StatusCode, String)> {
    ///     let file = File::open("Cargo.toml")
    /// let app = Router::new().route("/Cargo.toml", get(cargo_toml));
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/axum-extra/src/body/async_read_body.rs
///  async fn cargo_toml() -> Result<Attachment<String>, (StatusCode, String)> {
///      let file_contents = tokio::fs::read_to_string("Cargo.toml")
///          .filename("Cargo.toml")
///  let app = Router::new().route("/Cargo.toml", get(cargo_toml));
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/axum-extra/src/response/attachment.rs
/// This macro has no effect when compiled with the release profile. (eg. `cargo build --release`)
/// This macro has no effect when compiled with the release profile. (eg. `cargo build --release`)
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/axum-macros/src/lib.rs
        // cargo bench -- routing send-json
    let mut cmd = Command::new("cargo");
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/axum/benches/benches.rs
//! or just `full` to enable all features (`cargo add tokio --features macros,rt-multi-thread`).
//! [feature flags]: https://doc.rust-lang.org/cargo/reference/features.html#the-features-section
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/axum/src/lib.rs
//! cargo run -p example-anyhow-error-response
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/anyhow-error-response/src/main.rs
//! cargo run -p auto-reload
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/auto-reload/src/main.rs
//! cargo run -p example-chat
                .unwrap_or_else(|_| format!("{}=trace", env!("CARGO_CRATE_NAME")).into()),
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/chat/src/main.rs
                .unwrap_or_else(|_| format!("{}=trace", env!("CARGO_CRATE_NAME")).into()),
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/compression/src/main.rs
//! cargo run -p example-consume-body-in-extractor-or-middleware
                .unwrap_or_else(|_| format!("{}=debug", env!("CARGO_CRATE_NAME")).into()),
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/consume-body-in-extractor-or-middleware/src/main.rs
//! cargo run -p example-cors
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/cors/src/main.rs
//! cargo run -p example-customize-extractor-error
                .unwrap_or_else(|_| format!("{}=trace", env!("CARGO_CRATE_NAME")).into()),
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/customize-extractor-error/src/main.rs
//! cargo run -p example-customize-path-rejection
                .unwrap_or_else(|_| format!("{}=debug", env!("CARGO_CRATE_NAME")).into()),
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/customize-path-rejection/src/main.rs
//! cargo run -p example-dependency-injection
                .unwrap_or_else(|_| format!("{}=debug", env!("CARGO_CRATE_NAME")).into()),
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/dependency-injection/src/main.rs
//! cargo run -p example-diesel-async-postgres
                .unwrap_or_else(|_| format!("{}=debug", env!("CARGO_CRATE_NAME")).into()),
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/diesel-async-postgres/src/main.rs
//! cargo run -p example-diesel-postgres
// the migration path is relative to the `CARGO_MANIFEST_DIR`
                .unwrap_or_else(|_| format!("{}=debug", env!("CARGO_CRATE_NAME")).into()),
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/diesel-postgres/src/main.rs
//! cargo run -p example-error-handling
                format!("{}=debug,tower_http=debug", env!("CARGO_CRATE_NAME")).into()
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/error-handling/src/main.rs
//! cargo run -p example-form
                .unwrap_or_else(|_| format!("{}=debug", env!("CARGO_CRATE_NAME")).into()),
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/form/src/main.rs
//! cargo run -p example-global-404-handler
                .unwrap_or_else(|_| format!("{}=debug", env!("CARGO_CRATE_NAME")).into()),
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/global-404-handler/src/main.rs
//! cargo run -p example-graceful-shutdown
                    env!("CARGO_CRATE_NAME")
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/graceful-shutdown/src/main.rs
//! cargo run -p example-handle-head-request
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/handle-head-request/src/main.rs
//! cargo run -p example-hello-world
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/hello-world/src/main.rs
//! $ cargo run -p example-http-proxy
                format!("{}=trace,tower_http=debug", env!("CARGO_CRATE_NAME")).into()
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/http-proxy/src/main.rs
//! JWT_SECRET=secret cargo run -p example-jwt
                .unwrap_or_else(|_| format!("{}=debug", env!("CARGO_CRATE_NAME")).into()),
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/jwt/src/main.rs
//! cargo run -p example-key-value-store
                format!("{}=debug,tower_http=debug", env!("CARGO_CRATE_NAME")).into()
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/key-value-store/src/main.rs
//! cargo run -p example-low-level-native-tls
        PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        PathBuf::from(env!("CARGO_MANIFEST_DIR"))
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/low-level-native-tls/src/main.rs
//! cargo run -p example-low-level-openssl
                .unwrap_or_else(|_| format!("{}=debug", env!("CARGO_CRATE_NAME")).into()),
            PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            PathBuf::from(env!("CARGO_MANIFEST_DIR"))
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/low-level-openssl/src/main.rs
//! cargo run -p example-low-level-rustls
                .unwrap_or_else(|_| format!("{}=debug", env!("CARGO_CRATE_NAME")).into()),
        PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        PathBuf::from(env!("CARGO_MANIFEST_DIR"))
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/low-level-rustls/src/main.rs
//! cargo run -p example-mongodb
                format!("{}=debug,tower_http=debug", env!("CARGO_CRATE_NAME")).into()
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/mongodb/src/main.rs
//! cargo run -p example-multipart-form
                format!("{}=debug,tower_http=debug", env!("CARGO_CRATE_NAME")).into()
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/multipart-form/src/main.rs
//! CLIENT_ID=REPLACE_ME CLIENT_SECRET=REPLACE_ME cargo run -p example-oauth
                .unwrap_or_else(|_| format!("{}=debug", env!("CARGO_CRATE_NAME")).into()),
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/oauth/src/main.rs
//! cargo run -p example-parse-body-based-on-content-type
                format!("{}=debug,tower_http=debug", env!("CARGO_CRATE_NAME")).into()
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/parse-body-based-on-content-type/src/main.rs
//! cargo run -p example-print-request-response
                format!("{}=debug,tower_http=debug", env!("CARGO_CRATE_NAME")).into()
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/print-request-response/src/main.rs
//! cargo run -p example-prometheus-metrics
                format!("{}=debug,tower_http=debug", env!("CARGO_CRATE_NAME")).into()
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/prometheus-metrics/src/main.rs
//! cargo run -p example-query-params-with-empty-strings
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/query-params-with-empty-strings/src/main.rs
//! cargo run -p example-readme
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/readme/src/main.rs
//! cargo run -p example-request-id
                    env!("CARGO_CRATE_NAME")
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/request-id/src/main.rs
//! cargo run -p example-reqwest-response
                format!("{}=debug,tower_http=debug", env!("CARGO_CRATE_NAME")).into()
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/reqwest-response/src/main.rs
//! cargo run -p example-reverse-proxy
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/reverse-proxy/src/main.rs
//! cargo run -p example-routes-and-handlers-close-together
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/routes-and-handlers-close-together/src/main.rs
//! cargo run -p example-serve-with-hyper
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/serve-with-hyper/src/main.rs
//! cargo run -p example-simple-router-wasm
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/simple-router-wasm/src/main.rs
//! cargo run -p example-sqlx-postgres
                .unwrap_or_else(|_| format!("{}=debug", env!("CARGO_CRATE_NAME")).into()),
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/sqlx-postgres/src/main.rs
//! cargo run -p example-sse
//! cargo test -p example-sse
                format!("{}=debug,tower_http=debug", env!("CARGO_CRATE_NAME")).into()
    let assets_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("assets");
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/sse/src/main.rs
//! cargo run -p example-static-file-server
                format!("{}=debug,tower_http=debug", env!("CARGO_CRATE_NAME")).into()
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/static-file-server/src/main.rs
//! cargo run -p example-stream-to-file
                .unwrap_or_else(|_| format!("{}=debug", env!("CARGO_CRATE_NAME")).into()),
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/stream-to-file/src/main.rs
//! cargo run -p example-templates-minijinja
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/templates-minijinja/src/main.rs
//! cargo run -p example-templates
                .unwrap_or_else(|_| format!("{}=debug", env!("CARGO_CRATE_NAME")).into()),
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/templates/src/main.rs
//! cargo test -p example-testing-websockets
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/testing-websockets/src/main.rs
//! cargo test -p example-testing
                format!("{}=debug,tower_http=debug", env!("CARGO_CRATE_NAME")).into()
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/testing/src/main.rs
//! cargo run -p example-tls-graceful-shutdown
                .unwrap_or_else(|_| format!("{}=debug", env!("CARGO_CRATE_NAME")).into()),
        PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        PathBuf::from(env!("CARGO_MANIFEST_DIR"))
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/tls-graceful-shutdown/src/main.rs
//! cargo run -p example-tls-rustls
                .unwrap_or_else(|_| format!("{}=debug", env!("CARGO_CRATE_NAME")).into()),
        PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        PathBuf::from(env!("CARGO_MANIFEST_DIR"))
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/tls-rustls/src/main.rs
//! cargo run -p example-todos
                format!("{}=debug,tower_http=debug", env!("CARGO_CRATE_NAME")).into()
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/todos/src/main.rs
//! cargo run -p example-tokio-postgres
                .unwrap_or_else(|_| format!("{}=debug", env!("CARGO_CRATE_NAME")).into()),
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/tokio-postgres/src/main.rs
//! cargo run -p example-tokio-redis
                .unwrap_or_else(|_| format!("{}=debug", env!("CARGO_CRATE_NAME")).into()),
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/tokio-redis/src/main.rs
//! cargo run -p example-tracing-aka-logging
                    env!("CARGO_CRATE_NAME")
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/tracing-aka-logging/src/main.rs
//! cargo run -p example-unix-domain-socket
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/unix-domain-socket/src/main.rs
//! cargo run -p example-validator
                .unwrap_or_else(|_| format!("{}=debug", env!("CARGO_CRATE_NAME")).into()),
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/validator/src/main.rs
//! cargo run -p example-versioning
                .unwrap_or_else(|_| format!("{}=debug", env!("CARGO_CRATE_NAME")).into()),
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/versioning/src/main.rs
//! cargo run -p example-websockets-http2
                .unwrap_or_else(|_| format!("{}=debug", env!("CARGO_CRATE_NAME")).into()),
    let assets_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("assets");
        PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        PathBuf::from(env!("CARGO_MANIFEST_DIR"))
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/websockets-http2/src/main.rs
//! cargo run -p example-websockets --bin example-websockets
//! cargo run -p example-websockets --bin example-client
                format!("{}=debug,tower_http=debug", env!("CARGO_CRATE_NAME")).into()
    let assets_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("assets");
./vendor/meta-introspector/solfunmeme-dioxus/vendor/axum/examples/websockets/src/main.rs
    println!("cargo:rerun-if-changed=build.rs");
            println!("cargo:info={builder:?}");
./vendor/meta-introspector/solfunmeme-dioxus/vendor/candle/candle-examples/build.rs
    println!("cargo:rerun-if-changed=build.rs");
        println!("cargo:rerun-if-changed={kernel_file}");
    println!("cargo:rerun-if-changed=kernels/flash_fwd_kernel.h");
    println!("cargo:rerun-if-changed=kernels/flash_fwd_launch_template.h");
    println!("cargo:rerun-if-changed=kernels/flash.h");
    println!("cargo:rerun-if-changed=kernels/philox.cuh");
    println!("cargo:rerun-if-changed=kernels/softmax.h");
    println!("cargo:rerun-if-changed=kernels/utils.h");
    println!("cargo:rerun-if-changed=kernels/kernel_traits.h");
    println!("cargo:rerun-if-changed=kernels/block_info.h");
    println!("cargo:rerun-if-changed=kernels/static_switch.h");
    println!("cargo:rerun-if-changed=kernels/hardware_info.h");
    println!("cargo:rustc-link-search={}", build_dir.display());
    println!("cargo:rustc-link-lib=flashattention");
    println!("cargo:rustc-link-lib=dylib=cudart");
        println!("cargo:rustc-link-lib=dylib=stdc++");
./vendor/meta-introspector/solfunmeme-dioxus/vendor/candle/candle-flash-attn/build.rs
    println!("cargo:rerun-if-changed=build.rs");
    println!("cargo:rerun-if-changed=src/compatibility.cuh");
    println!("cargo:rerun-if-changed=src/cuda_utils.cuh");
    println!("cargo:rerun-if-changed=src/binary_op_macros.cuh");
    println!("cargo:info={builder:?}");
./vendor/meta-introspector/solfunmeme-dioxus/vendor/candle/candle-kernels/build.rs
//! cargo run --example bigcode --release -- --prompt "fn fact(n: u64) -> u64"
./vendor/meta-introspector/solfunmeme-dioxus/vendor/candle/candle-transformers/src/models/bigcode.rs
//! cargo run \
//! cargo run \
./vendor/meta-introspector/solfunmeme-dioxus/vendor/candle/candle-transformers/src/models/dinov2.rs
//! cargo run \
./vendor/meta-introspector/solfunmeme-dioxus/vendor/candle/candle-transformers/src/models/dinov2reg4.rs
//! cargo run
./vendor/meta-introspector/solfunmeme-dioxus/vendor/candle/candle-transformers/src/models/efficientvit.rs
//! cargo run \
./vendor/meta-introspector/solfunmeme-dioxus/vendor/candle/candle-transformers/src/models/eva2.rs
//! cargo run --features cuda \
./vendor/meta-introspector/solfunmeme-dioxus/vendor/candle/candle-transformers/src/models/flux/mod.rs
//! cargo run --example mimi \
//! cargo run --example mimi
./vendor/meta-introspector/solfunmeme-dioxus/vendor/candle/candle-transformers/src/models/mimi/mod.rs
//! cargo run --example moondream \
./vendor/meta-introspector/solfunmeme-dioxus/vendor/candle/candle-transformers/src/models/moondream.rs
//! cargo run --example nvembed_v2 --release
//! cargo run --example nvembed_v2 --release -- --prompt "Here is a test sentence"
./vendor/meta-introspector/solfunmeme-dioxus/vendor/candle/candle-transformers/src/models/nvembed_v2/mod.rs
//! cargo run --profile=release-with-debug \
./vendor/meta-introspector/solfunmeme-dioxus/vendor/candle/candle-transformers/src/models/pixtral/mod.rs
//! cargo run --example rwkv --release -- \
./vendor/meta-introspector/solfunmeme-dioxus/vendor/candle/candle-transformers/src/models/rwkv_v5.rs
//! cargo run --example rwkv --release -- \
./vendor/meta-introspector/solfunmeme-dioxus/vendor/candle/candle-transformers/src/models/rwkv_v6.rs
//! cargo run --example segment-anything --release -- \
./vendor/meta-introspector/solfunmeme-dioxus/vendor/candle/candle-transformers/src/models/segment_anything/mod.rs
//! cargo run --example stable-diffusion --release --features=cuda,cudnn \
//! cargo run --example stable-diffusion --release --features=cuda,cudnn \
//! cargo run --example stable-diffusion --release --features=cuda,cudnn \
./vendor/meta-introspector/solfunmeme-dioxus/vendor/candle/candle-transformers/src/models/stable_diffusion/mod.rs
//! cargo run --example t5 --release -- \
//! cargo run --example t5 --release  -- \
//! cargo run --example t5 --release -- \
./vendor/meta-introspector/solfunmeme-dioxus/vendor/candle/candle-transformers/src/models/t5.rs
used by adding `dioxus-charts` to your dependencies in your project's `Cargo.toml`.
./vendor/meta-introspector/solfunmeme-dioxus/vendor/dioxus-charts/src/lib.rs
//! user@foo(eliza) ~> cargo run scripts/doctor.json
./vendor/meta-introspector/solfunmeme-dioxus/vendor/eliza-rs/src/main.rs
/// $ cargo run --example gpu --features=cuda
./vendor/meta-introspector/solfunmeme-dioxus/vendor/gline-rs/examples/benchmark_gpu.rs
//! $ cargo run --features openblas --example diabetes
//! $ cargo run --example glm
./vendor/meta-introspector/solfunmeme-dioxus/vendor/linfa/algorithms/linfa-linear/src/lib.rs
//! $ cargo run --example winequality
./vendor/meta-introspector/solfunmeme-dioxus/vendor/linfa/algorithms/linfa-logistic/src/lib.rs
    println!("cargo:rustc-link-lib=lapacke");
    println!("cargo:rustc-link-lib=lapack");
    println!("cargo:rustc-link-lib=cblas");
./vendor/meta-introspector/solfunmeme-dioxus/vendor/linfa/build.rs
/// cargo run example E.01
/// cargo run --features cuda example E.01
/// cargo run example E.02
/// cargo run --features cuda example E.02
/// cargo run example E.03
/// cargo run --features cuda example E.03
/// cargo run example E.04
/// cargo run --features cuda example E.04
/// cargo run example E.05
/// cargo run --features cuda example E.05
/// cargo run example E.06
/// cargo run --features cuda example E.06
/// cargo run example E.07
/// cargo run --features cuda example E.07
./vendor/meta-introspector/solfunmeme-dioxus/vendor/llms-from-scratch-rs/src/examples/apdx_e.rs
/// cargo run example 02.01
/// cargo run --features cuda example 02.01
/// cargo run example 02.02
/// cargo run --features cuda example 02.02
/// cargo run example 02.03
/// cargo run --features cuda example 02.03
/// cargo run example 02.04
/// cargo run --features cuda example 02.04
./vendor/meta-introspector/solfunmeme-dioxus/vendor/llms-from-scratch-rs/src/examples/ch02.rs
/// cargo run example 03.01
/// cargo run --features cuda example 03.01
/// cargo run example 03.02
/// cargo run --features cuda example 03.02
/// cargo run example 03.03
/// cargo run --features cuda example 03.03
/// cargo run example 03.04
/// cargo run --features cuda example 03.04
/// cargo run example 03.05
/// cargo run --features cuda example 03.05
/// cargo run example 03.06
/// cargo run --features cuda example 03.06
/// cargo run example 03.07
/// cargo run --features cuda example 03.07
/// cargo run example 03.08
/// cargo run --features cuda example 03.08
/// cargo run example 03.09
/// cargo run --features cuda example 03.09
/// cargo run example 03.10
/// cargo run --features cuda example 03.10
/// cargo run example 03.11
/// cargo run --features cuda example 03.11
./vendor/meta-introspector/solfunmeme-dioxus/vendor/llms-from-scratch-rs/src/examples/ch03.rs
/// cargo run example 04.01
/// cargo run --features cuda example 04.01
/// cargo run example 04.02
/// cargo run --features cuda example 04.02
/// cargo run example 04.03
/// cargo run --features cuda example 04.03
/// cargo run example 04.04
/// cargo run --features cuda example 04.04
/// cargo run example 04.05
/// cargo run --features cuda example 04.05
/// cargo run example 04.06
/// cargo run --features cuda example 04.06
/// cargo run example 04.07
/// cargo run --features cuda example 04.07
/// cargo run example 04.08
/// cargo run --features cuda example 04.08
./vendor/meta-introspector/solfunmeme-dioxus/vendor/llms-from-scratch-rs/src/examples/ch04.rs
/// cargo run example 05.01
/// cargo run --features cuda example 05.01
/// cargo run example 05.02
/// cargo run --features cuda example 05.02
/// cargo run example 05.03
/// cargo run --features cuda example 05.03
/// cargo run example 05.04
/// cargo run --features cuda example 05.04
/// cargo run example 05.05
/// cargo run --features cuda example 05.05
/// cargo run example 05.06
/// cargo run --features cuda example 05.06
/// cargo run example 05.07
/// cargo run --features cuda example 05.07
/// cargo run example 05.08
/// cargo run --features cuda example 05.08
/// cargo run example 05.09
/// cargo run --features cuda example 05.09
/// cargo run example 05.10
/// cargo run --features cuda example 05.10
/// cargo run example 05.11
/// cargo run --features cuda example 05.11
./vendor/meta-introspector/solfunmeme-dioxus/vendor/llms-from-scratch-rs/src/examples/ch05.rs
/// cargo run example 06.01
/// cargo run --features cuda example 06.01
/// cargo run example 06.02
/// cargo run --features cuda example 06.02
/// cargo run example 06.03
/// cargo run --features cuda example 06.03
/// cargo run example 06.04
/// cargo run --features cuda example 06.04
/// cargo run example 06.05
/// cargo run --features cuda example 06.05
/// cargo run example 06.06
/// cargo run --features cuda example 06.06
/// cargo run example 06.07
/// cargo run --features cuda example 06.07
/// cargo run example 06.08
/// cargo run --features cuda example 06.08
/// cargo run example 06.09
/// cargo run --features cuda example 06.09
/// cargo run example 06.10
/// cargo run --features cuda example 06.10
/// cargo run example 06.11
/// cargo run --features cuda example 06.11
/// cargo run example 06.12
/// cargo run --features cuda example 06.12
/// cargo run example 06.13
/// cargo run --features cuda example 06.13
/// cargo run example 06.14
/// cargo run --features cuda example 06.14
/// cargo run example 06.15
/// cargo run --features cuda example 06.15
./vendor/meta-introspector/solfunmeme-dioxus/vendor/llms-from-scratch-rs/src/examples/ch06.rs
/// cargo run example 07.01
/// cargo run --features cuda example 07.01
/// cargo run example 07.02
/// cargo run --features cuda example 07.02
/// cargo run example 07.03
/// cargo run --features cuda example 07.03
/// cargo run example 07.04
/// cargo run --features cuda example 07.04
/// cargo run example 07.05
/// cargo run --features cuda example 07.05
/// cargo run example 07.06
/// cargo run --features cuda example 07.06
/// cargo run example 07.07
/// cargo run --features cuda example 07.07
/// cargo run example 07.08
/// cargo run --features cuda example 07.08
/// cargo run example 07.09
/// cargo run --features cuda example 07.09
/// cargo run example 07.10
/// cargo run --features cuda example 07.10
/// cargo run example 07.11
/// cargo run --features cuda example 07.11
/// cargo run example 07.12
/// cargo run --features cuda example 07.12
/// cargo run example 07.13
/// cargo run --features cuda example 07.13
/// cargo run example 07.14
/// cargo run --features cuda example 07.14
/// cargo run example 07.15
/// cargo run --features cuda example 07.15
/// cargo run example 07.16
/// cargo run --features cuda example 07.16
/// cargo run example 07.17
/// cargo run --features cuda example 07.17
/// cargo run example 07.18
/// cargo run --features cuda example 07.18
/// cargo run example 07.19
/// cargo run --features cuda example 07.19
/// cargo run example 07.20
/// cargo run --features cuda example 07.20
/// cargo run example 07.21
/// cargo run --features cuda example 07.21
/// cargo run example 07.22
/// cargo run --features cuda example 07.22
/// cargo run example 07.23
/// cargo run --features cuda example 07.23
./vendor/meta-introspector/solfunmeme-dioxus/vendor/llms-from-scratch-rs/src/examples/ch07.rs
/// cargo run exercise 2.1
/// cargo run --features cuda exercise 2.1
/// cargo run exercise 2.2
/// cargo run --features cuda exercise 2.2
./vendor/meta-introspector/solfunmeme-dioxus/vendor/llms-from-scratch-rs/src/exercises/ch02.rs
/// cargo run exercise 3.1
/// cargo run --features cuda exercise 3.1
/// cargo run exercise 3.2
/// cargo run --features cuda exercise 3.2
/// cargo run exercise 3.3
/// cargo run --features cuda exercise 3.3
./vendor/meta-introspector/solfunmeme-dioxus/vendor/llms-from-scratch-rs/src/exercises/ch03.rs
/// cargo run exercise 4.1
/// cargo run --features cuda exercise 4.1
/// cargo run exercise 4.2
/// cargo run --features cuda exercise 4.2
/// cargo run exercise 4.3
/// cargo run --features cuda exercise 4.3
./vendor/meta-introspector/solfunmeme-dioxus/vendor/llms-from-scratch-rs/src/exercises/ch04.rs
/// cargo run exercise 5.1
/// cargo run --features cuda exercise 5.1
/// cargo run exercise 5.2
/// cargo run --features cuda exercise 5.2
/// cargo run exercise 5.3
/// cargo run --features cuda exercise 5.3
/// cargo run exercise 5.4
/// cargo run --features cuda exercise 5.4
/// cargo run exercise 5.5
/// cargo run --features cuda exercise 5.5
/// cargo run exercise 5.6
/// cargo run --features cuda exercise 5.6
./vendor/meta-introspector/solfunmeme-dioxus/vendor/llms-from-scratch-rs/src/exercises/ch05.rs
/// cargo run exercise 6.1
/// cargo run --features cuda exercise 6.1
/// cargo run exercise 6.2
/// cargo run --features cuda exercise 6.2
/// cargo run exercise 6.3
/// cargo run --features cuda exercise 6.3
./vendor/meta-introspector/solfunmeme-dioxus/vendor/llms-from-scratch-rs/src/exercises/ch06.rs
/// cargo run exercise 7.1
/// cargo run --features cuda exercise 7.1
/// cargo run exercise 7.2
/// cargo run --features cuda exercise 7.2
/// cargo run exercise 7.3
/// cargo run --features cuda exercise 7.3
/// cargo run exercise 7.4
/// cargo run --features cuda exercise 7.4
./vendor/meta-introspector/solfunmeme-dioxus/vendor/llms-from-scratch-rs/src/exercises/ch07.rs
    // Tell Cargo that if the given environment variable changes, to rerun this build script.
    println!("cargo:rerun-if-changed=build.template");
    println!("cargo:rerun-if-env-changed=RHAI_AHASH_SEED");
    println!("cargo:rerun-if-env-changed=RHAI_HASHING_SEED");
./vendor/meta-introspector/solfunmeme-dioxus/vendor/rhai/build.rs
    let title = format!("Rhai Debugger (version {})", env!("CARGO_PKG_VERSION"));
./vendor/meta-introspector/solfunmeme-dioxus/vendor/rhai/src/bin/rhai-dbg.rs
    let title = format!("Rhai REPL tool (version {})", env!("CARGO_PKG_VERSION"));
./vendor/meta-introspector/solfunmeme-dioxus/vendor/rhai/src/bin/rhai-repl.rs
#![warn(clippy::cargo)]
./vendor/meta-introspector/solfunmeme-dioxus/vendor/rhai/src/lib.rs
  // Base relative paths on the Cargo.toml location
    let absolute_path = Path::new(&env::var("CARGO_MANIFEST_DIR").unwrap())
./vendor/meta-introspector/solfunmeme-dioxus/vendor/rust-embed/impl/src/lib.rs
#[folder = "$CARGO_MANIFEST_DIR/examples/public/"]
./vendor/meta-introspector/solfunmeme-dioxus/vendor/rust-embed/tests/interpolated_path.rs
  let metadata = fs::metadata(format!("{}/examples/public/index.html", env!("CARGO_MANIFEST_DIR"))).unwrap();
  let metadata = fs::metadata(format!("{}/examples/public/index.html", env!("CARGO_MANIFEST_DIR"))).unwrap();
  let metadata = fs::metadata(format!("{}/examples/public/index.html", env!("CARGO_MANIFEST_DIR"))).unwrap();
./vendor/meta-introspector/solfunmeme-dioxus/vendor/rust-embed/tests/metadata.rs
/// Cargo.toml now specifies the MSRV bounds, which enables tooling to report an early failure when
/// * Remove use of `build.rs` making it easier to build `libloading` without cargo. It also
/// * `cargo test --release` now works when testing libloading.
///   * Actually, it is cargo which has to be more recent here. The one shipped with rustc 1.14.0
./vendor/meta-introspector/solfunmeme-dioxus/vendor/rust_libloading/src/changelog.rs
//! Add the `libloading` library to your dependencies in `Cargo.toml`:
./vendor/meta-introspector/solfunmeme-dioxus/vendor/rust_libloading/src/lib.rs
const TARGET_DIR: Option<&'static str> = option_env!("CARGO_TARGET_DIR");
const TARGET_TMPDIR: Option<&'static str> = option_env!("CARGO_TARGET_TMPDIR");
./vendor/meta-introspector/solfunmeme-dioxus/vendor/rust_libloading/tests/functions.rs
//! usage: cargo run --example jsonld-context <JSON-LD file> [context file]
./vendor/meta-introspector/solfunmeme-dioxus/vendor/sophia_rs/sophia/examples/jsonld-context.rs
        use vergen::{BuildBuilder, CargoBuilder, Emitter, RustcBuilder};
        let cargo = CargoBuilder::all_cargo()?;
            .add_instructions(&cargo)?
./vendor/meta-introspector/solfunmeme-dioxus/vendor/steel/build.rs
use cargo_metadata::{Message, MetadataCommand, Package, TargetKind};
        None => return Err("cargo steel-lib must be run from within a crate".into()),
    let mut command = Command::new("cargo")
    let artifacts = cargo_metadata::Message::parse_stream(reader).filter_map(|x| {
    let exit_status = command.wait().expect("Couldn't get cargo's exit status");
./vendor/meta-introspector/solfunmeme-dioxus/vendor/steel/crates/cargo-steel-lib/src/lib.rs
    if cargo_steel_lib::run(args, Vec::new())? {
            String::from("cargo build failed to complete successfully").into();
./vendor/meta-introspector/solfunmeme-dioxus/vendor/steel/crates/cargo-steel-lib/src/main.rs
    println!("cargo::rerun-if-changed=installer/");
./vendor/meta-introspector/solfunmeme-dioxus/vendor/steel/crates/forge/build.rs
        println!("cargo:rerun-if-changed=build.rs");
./vendor/meta-introspector/solfunmeme-dioxus/vendor/steel/crates/steel-core/build.rs
        // self.version == env!("CARGO_PKG_VERSION")
./vendor/meta-introspector/solfunmeme-dioxus/vendor/steel/crates/steel-core/src/steel_vm/builtin.rs
                cargo_steel_lib::run(_args, _env_vars)
./vendor/meta-introspector/solfunmeme-dioxus/vendor/steel/crates/steel-core/src/steel_vm/primitives.rs
        env!("CARGO_PKG_VERSION")
./vendor/meta-introspector/solfunmeme-dioxus/vendor/steel/crates/steel-repl/src/repl.rs
    println!("cargo:rerun-if-changed-env=TARGET")
    println!("cargo:rustc-env={}={}", name, value);
./vendor/meta-introspector/solfunmeme-dioxus/vendor/steel/crates/xtask/build.rs
    let output = std::process::Command::new(env!("CARGO"))
    let cargo_path = Path::new(std::str::from_utf8(&output).unwrap().trim());
    cargo_path.parent().unwrap().to_path_buf()
    std::process::Command::new("cargo")
    // Check if cargo pgo is installed
    if which::which("cargo-pgo").is_ok() {
        println!("`cargo-pgo` found - building with PGO");
        std::process::Command::new("cargo")
    std::process::Command::new("cargo")
    workspace_dir.push("cargo-steel-lib");
    println!("Installing `cargo-steel-lib`");
    std::process::Command::new("cargo")
    println!("Successfully installed `cargo-steel-lib`");
    std::process::Command::new("cargo")
    std::process::Command::new("cargo")
    std::process::Command::new("cargo")
    std::process::Command::new("cargo")
    std::process::Command::new("cargo")
    let mut cargo_bin_location = which::which("cargo").expect("Unable to find cargo");
    cargo_bin_location.pop();
    cargo_bin_location.push("steel");
    println!("Installing to: {:?}", cargo_bin_location);
    std::fs::copy(binary, cargo_bin_location).unwrap();
./vendor/meta-introspector/solfunmeme-dioxus/vendor/steel/crates/xtask/src/main.rs
    std::process::Command::new("cargo-steel-lib")
./vendor/meta-introspector/solfunmeme-dioxus/vendor/steel/libs/steel-rustls/src/main.rs
    env!("CARGO_PKG_VERSION"),
            temporary_output.push("Cargo.toml");
            std::process::Command::new("cargo")
            cargo_steel_lib::run(Vec::new(), Vec::new())?;
./vendor/meta-introspector/solfunmeme-dioxus/vendor/steel/src/lib.rs
    major: env!("CARGO_PKG_VERSION_MAJOR").parse().unwrap(),
    minor: env!("CARGO_PKG_VERSION_MINOR").parse().unwrap(),
    patch: env!("CARGO_PKG_VERSION_PATCH").parse().unwrap(),
/// Expose the current version of tantivy as found in Cargo.toml during compilation.
/// Exposes the complete version of tantivy as found in Cargo.toml during compilation as a string.
./vendor/meta-introspector/solfunmeme-dioxus/vendor/tantivy/src/lib.rs
    println!("cargo:rustc-link-search={}", out.display());
    println!("cargo:rerun-if-changed=memory.x");
./vendor/meta-introspector/solfunmeme-dioxus/vendor/vaporetto/examples/embedded_device/build.rs
pub const VERSION: &str = env!("CARGO_PKG_VERSION");
./vendor/meta-introspector/solfunmeme-dioxus/vendor/vaporetto/vaporetto/src/lib.rs
pub const VERSION: &str = env!("CARGO_PKG_VERSION");
./vendor/meta-introspector/solfunmeme-dioxus/vendor/vibrato/vibrato/src/lib.rs
                    .help("Cargo registry's local TCP port. The server will bind to this port and wait for requests."),
./vendor/meta-introspector/agave-solana-validator/cargo-registry/src/client.rs
        UnpackedCrate::fixup_toml(&unpacked.tempdir, "Cargo.toml.orig", &unpacked.meta, &name)?;
        UnpackedCrate::fixup_toml(&unpacked.tempdir, "Cargo.toml", &unpacked.meta, &name)?;
        // Generate a Cargo.toml
        let toml_content = fs::read_to_string(Self::make_path(tempdir, meta, "Cargo.toml.orig"))?;
        cargo_toml_name: &str,
        let toml_orig_path = Self::make_path(tempdir, meta, cargo_toml_name);
./vendor/meta-introspector/agave-solana-validator/cargo-registry/src/crate_handler.rs
//! The `registry_service` module implements the Solana cargo registry service.
pub struct CargoRegistryService {}
impl CargoRegistryService {
                CargoRegistryService::handler(index.clone(), request, client_inner.clone())
./vendor/meta-introspector/agave-solana-validator/cargo-registry/src/main.rs
        // https://doc.rust-lang.org/cargo/reference/registry-index.html#index-files
./vendor/meta-introspector/agave-solana-validator/cargo-registry/src/sparse_index.rs
        let mut pathbuf = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
./vendor/meta-introspector/agave-solana-validator/cli/src/program.rs
    let mut noop_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let mut noop_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let mut program_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let mut noop_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let mut syscall_program_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let mut noop_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let mut noop_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let mut noop_large_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let mut noop_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let mut noop_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let mut noop_large_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let mut noop_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let mut noop_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let mut noop_large_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let mut program_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let mut noop_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let mut noop_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let mut noop_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let mut noop_large_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let mut noop_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let mut noop_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let mut noop_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let mut noop_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
./vendor/meta-introspector/agave-solana-validator/cli/tests/program.rs
//! Run with cargo
//! cargo test all_partitions --release -- --nocapture --ignored
./vendor/meta-introspector/agave-solana-validator/core/tests/fork-selection.rs
        "cargo:rustc-env=TARGET={}",
        "cargo:rustc-env=BUILD_SECONDS_SINCE_UNIX_EPOCH={}",
./vendor/meta-introspector/agave-solana-validator/install/build.rs
        let root_dir = env::var("CARGO_MANIFEST_DIR").expect("$CARGO_MANIFEST_DIR");
./vendor/meta-introspector/agave-solana-validator/install/src/config.rs
    Command::cargo_bin(env!("CARGO_PKG_NAME"))
./vendor/meta-introspector/agave-solana-validator/ledger-tool/tests/basic.rs
//! According to the cargo documentation, integration tests are compiled as individual crates.
./vendor/meta-introspector/agave-solana-validator/local-cluster/src/integration_tests.rs
            println!("cargo:rustc-cfg=build_target_feature_avx");
            println!("cargo:rustc-cfg=build_target_feature_avx2");
./vendor/meta-introspector/agave-solana-validator/perf/build.rs
    cargo_metadata::camino::Utf8PathBuf,
    cargo_args: Vec<&'a str>,
            cargo_args: vec![],
        error!("cargo-build-sbf exited on command execution failure");
            "cargo-build-sbf-child-script-{}.sh",
    // Early return here in case it's the first time we're running `cargo build-sbf`
    // cargo-build-sbf.  Remove the target_path directory in this
        || !binaries.join("cargo").try_exists().unwrap_or(false)
    package: &cargo_metadata::Package,
    metadata: &cargo_metadata::Metadata,
        // RUSTC variable overrides cargo +<toolchain> mechanism of
        // selecting the rust compiler and makes cargo run a rust compiler
                "Removed RUSTC from cargo environment, because it overrides +solana cargo command line option."
            "The Solana toolchain is corrupted. Please, run cargo-build-sbf with the \
    let cargo_target = format!(
        "CARGO_TARGET_{}_RUSTFLAGS",
            "Removed RUSTFLAGS from cargo environment, because it overrides {}.",
            cargo_target,
    let target_rustflags = env::var(&cargo_target).ok();
        env::set_var(&cargo_target, flags);
            cargo_target,
            env::var(&cargo_target).ok().unwrap_or_default(),
    let cargo_build = PathBuf::from("cargo");
    let mut cargo_build_args = vec![];
        cargo_build_args.push("+solana");
    cargo_build_args.append(&mut vec!["build", "--release", "--target", &target_triple]);
        cargo_build_args.push("--no-default-features");
        cargo_build_args.push("--features");
        cargo_build_args.push(feature);
        cargo_build_args.push("--verbose");
        cargo_build_args.push("--jobs");
        cargo_build_args.push(jobs);
    cargo_build_args.append(&mut config.cargo_args.clone());
        &cargo_build,
        &cargo_build_args,
    let mut metadata_command = cargo_metadata::MetadataCommand::new();
    // When run as a cargo subcommand, the first program argument is the subcommand name.
    // separate cargo caches according to the version of platform-tools.
            Arg::new("cargo_args")
                .help("Arguments passed directly to `cargo build`")
                .help("Do not use rustup to manage the toolchain. By default, cargo-build-sbf invokes rustup to find the Solana rustc using a `+solana` toolchain override. This flag disables that behavior."),
                .help("Path to Cargo.toml"),
    let mut cargo_args = matches
        .values_of("cargo_args")
    let target_directory = if let Some(target_dir) = cargo_args
        cargo_args,
./vendor/meta-introspector/agave-solana-validator/platform-tools-sdk/cargo-build-sbf/src/main.rs
fn run_cargo_build(crate_name: &str, extra_args: &[&str], fail: bool) {
        .join("Cargo.toml");
    let mut cmd = assert_cmd::Command::cargo_bin("cargo-build-sbf").unwrap();
    run_cargo_build("noop", &[], false);
    assert_cmd::Command::new("cargo")
    run_cargo_build("noop", &["--dump"], false);
    run_cargo_build("noop", &["--sbf-out-dir", "tmp_out"], false);
    run_cargo_build("noop", &["--", "--target-dir", target_dir], false);
    run_cargo_build(
    run_cargo_build("fail", &["--generate-child-script-on-failure"], true);
        .join("cargo-build-sbf-child-script-cargo.sh");
    run_cargo_build("noop", &["--arch", arch], false);
    run_cargo_build("package-metadata", &[], false);
    run_cargo_build("workspace-metadata", &[], false);
    run_cargo_build("noop", &[], false);
            .join("Cargo.toml");
        let mut cmd = assert_cmd::Command::cargo_bin("cargo-build-sbf").unwrap();
    fs::rename(bin_folder.join("cargo"), bin_folder.join("cargo_2"))
    fs::rename(bin_folder.join("cargo_2"), bin_folder.join("cargo"))
./vendor/meta-introspector/agave-solana-validator/platform-tools-sdk/cargo-build-sbf/tests/crates.rs
    cargo: PathBuf,
    cargo_build_sbf: PathBuf,
    extra_cargo_test_args: Vec<String>,
            cargo: PathBuf::from("cargo"),
            cargo_build_sbf: PathBuf::from("cargo-build-sbf"),
            extra_cargo_test_args: vec![],
        error!("cargo-test-sbf exited on command execution failure");
            "cargo-test-sbf-child-script-{}.sh",
    package: &cargo_metadata::Package,
    let mut cargo_args = vec!["--manifest-path", &manifest_path];
        cargo_args.push("--no-default-features");
        cargo_args.push("--features");
        cargo_args.push(feature);
        cargo_args.push("--verbose");
        cargo_args.push("--jobs");
        cargo_args.push(jobs);
    let mut build_sbf_args = cargo_args.clone();
        &config.cargo_build_sbf,
    cargo_args.insert(0, "test");
            cargo_args.push("-p");
            cargo_args.push(package);
        cargo_args.push("--test");
        cargo_args.push(test_name);
        cargo_args.push("--no-run");
    // distinguish between `cargo test` and `cargo test-sbf`
        cargo_args.push("--features");
        cargo_args.push("test-sbf");
        cargo_args.push("--features");
        cargo_args.push("test-bpf");
    for extra_cargo_test_arg in &config.extra_cargo_test_args {
        cargo_args.push(extra_cargo_test_arg);
        &config.cargo,
        &cargo_args,
    let mut metadata_command = cargo_metadata::MetadataCommand::new();
    // When run as a cargo subcommand, the first program argument is the subcommand name.
                .help("Path to Cargo.toml"),
            Arg::new("extra_cargo_test_args")
                .value_name("extra args for cargo test and the test binary")
                .help("All extra arguments are passed through to cargo test"),
        extra_cargo_test_args: matches
            .values_of_t("extra_cargo_test_args")
    if let Ok(cargo_build_sbf) = env::var("CARGO_BUILD_SBF") {
        config.cargo_build_sbf = PathBuf::from(cargo_build_sbf);
    if let Ok(cargo_build_sbf) = env::var("CARGO") {
        config.cargo = PathBuf::from(cargo_build_sbf);
    // clap.rs swallows "--" in the case when the user provides it as the first `extra_cargo_test_args`
    // For example, this command-line "cargo-test-sbf -- --nocapture" results in `extra_cargo_test_args` only
    // containing "--nocapture".  This is a problem because `cargo test` will never see the `--`.
    // Whereas "cargo-test-sbf testname --  --nocapture" correctly produces a `extra_cargo_test_args`
    // So if the original cargo-test-sbf arguments contain "--" but `extra_cargo_test_args` does
    if args_contain_dashash && !config.extra_cargo_test_args.contains(&em_dash) {
        config.extra_cargo_test_args.insert(0, em_dash);
./vendor/meta-introspector/agave-solana-validator/platform-tools-sdk/cargo-test-sbf/src/main.rs
        let warn = format!("/* DO NOT MODIFY THIS GENERATED FILE. INSTEAD CHANGE {} AND RUN `cargo run --bin gen-headers` */", inc.display());
./vendor/meta-introspector/agave-solana-validator/platform-tools-sdk/gen-headers/src/main.rs
    /// used to override this preference at runtime.  `cargo test-bpf` will set `BPF_OUT_DIR`
./vendor/meta-introspector/agave-solana-validator/program-test/src/lib.rs
 * for distribution with the SDK.  This file is read by cargo-build-sbf
 * to verify undefined symbols in a .so module that cargo-build-sbf has built.
        "cargo:warning=(not a warning) Generating {1} from {0}",
./vendor/meta-introspector/agave-solana-validator/programs/bpf_loader/gen-syscall-list/build.rs
        // cargo-build-sbf and ensure it is working correctly.
./vendor/meta-introspector/agave-solana-validator/programs/sbf/tests/programs.rs
    let manifest_dir = std::path::PathBuf::from(env!("CARGO_MANIFEST_DIR"));
./vendor/meta-introspector/agave-solana-validator/storage-bigtable/build-proto/src/main.rs
            env!("CARGO_MANIFEST_DIR"),
                env!("CARGO_MANIFEST_DIR"),
./vendor/meta-introspector/agave-solana-validator/storage-bigtable/src/bigtable.rs
        println!("cargo:rerun-if-changed={}", proto.display());
./vendor/meta-introspector/agave-solana-validator/storage-proto/build.rs
        .for_each(|proto| println!("cargo:rerun-if-changed={}", proto.display()));
./vendor/meta-introspector/agave-solana-validator/svm-conformance/build.rs
        let mut conf_file = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
./vendor/meta-introspector/agave-solana-validator/thread-manager/examples/core_contention_basics.rs
            let mut conffile = std::path::PathBuf::from(env!("CARGO_MANIFEST_DIR"));
./vendor/meta-introspector/agave-solana-validator/thread-manager/src/lib.rs
                    env!("CARGO_MANIFEST_DIR"),
./vendor/meta-introspector/agave-solana-validator/transaction-dos/src/main.rs
    let mut cmd = Command::cargo_bin(env!("CARGO_PKG_NAME")).unwrap();
./vendor/meta-introspector/agave-solana-validator/validator/tests/cli.rs
                println!("cargo:rustc-env=AGAVE_GIT_COMMIT_HASH={}", trimmed_hash);
./vendor/meta-introspector/agave-solana-validator/version/build.rs
            major: env!("CARGO_PKG_VERSION_MAJOR").parse().unwrap(),
            minor: env!("CARGO_PKG_VERSION_MINOR").parse().unwrap(),
            patch: env!("CARGO_PKG_VERSION_PATCH").parse().unwrap(),
./vendor/meta-introspector/agave-solana-validator/version/src/legacy.rs
            major: env!("CARGO_PKG_VERSION_MAJOR").parse().unwrap(),
            minor: env!("CARGO_PKG_VERSION_MINOR").parse().unwrap(),
            patch: env!("CARGO_PKG_VERSION_PATCH").parse().unwrap(),
./vendor/meta-introspector/agave-solana-validator/version/src/lib.rs
    println!("cargo:rerun-if-changed={}", proto.display());
./vendor/meta-introspector/agave-solana-validator/wen-restart/build.rs
    // The name as specified in Cargo.toml (with `-`).
    /// This is the workspace root of the cargo workspace for workspace members, the crate manifest
    /// A name used in the package's project declaration: for Cargo projects,
./vendor/rust-analyzer/crates/base-db/src/input.rs
    /// Cargo builds only on-disk files). We could and probably should add diagnostics for that.
./vendor/rust-analyzer/crates/hir-def/src/nameres/collector.rs
        // unnecessary diagnostics for eg. `CARGO_PKG_NAME`.
./vendor/rust-analyzer/crates/hir-expand/src/builtin/fn_macro.rs
// `env UPDATE_EXPECT=1 cargo test -p hir_ty` to update the snapshots.
./vendor/rust-analyzer/crates/hir-ty/src/tests.rs
    /// in the module tree of any target in `Cargo.toml`.
./vendor/rust-analyzer/crates/hir/src/lib.rs
//! Generated by `cargo xtask codegen assists-doc-tests`, do not edit by hand.
./vendor/rust-analyzer/crates/ide-assists/src/tests/generated.rs
//! Completes environment variables defined by Cargo
//! (<https://doc.rust-lang.org/cargo/reference/environment-variables.html>)
const CARGO_DEFINED_VARS: &[(&str, &str)] = &[
    ("CARGO", "Path to the cargo binary performing the build"),
    ("CARGO_MANIFEST_DIR", "The directory containing the manifest of your package"),
    ("CARGO_MANIFEST_PATH", "The path to the manifest of your package"),
    ("CARGO_PKG_VERSION", "The full version of your package"),
    ("CARGO_PKG_VERSION_MAJOR", "The major version of your package"),
    ("CARGO_PKG_VERSION_MINOR", "The minor version of your package"),
    ("CARGO_PKG_VERSION_PATCH", "The patch version of your package"),
    ("CARGO_PKG_VERSION_PRE", "The pre-release version of your package"),
    ("CARGO_PKG_AUTHORS", "Colon separated list of authors from the manifest of your package"),
    ("CARGO_PKG_NAME", "The name of your package"),
    ("CARGO_PKG_DESCRIPTION", "The description from the manifest of your package"),
    ("CARGO_PKG_HOMEPAGE", "The home page from the manifest of your package"),
    ("CARGO_PKG_REPOSITORY", "The repository from the manifest of your package"),
    ("CARGO_PKG_LICENSE", "The license from the manifest of your package"),
    ("CARGO_PKG_LICENSE_FILE", "The license file from the manifest of your package"),
        "CARGO_PKG_RUST_VERSION",
    ("CARGO_CRATE_NAME", "The name of the crate that is currently being compiled"),
        "CARGO_BIN_NAME",
        "CARGO_PRIMARY_PACKAGE",
        "CARGO_TARGET_TMPDIR",
        "Only set when building integration test or benchmark code. This is a path to a directory inside the target directory where integration tests or benchmarks are free to put any data needed by the tests/benches. Cargo initially creates this directory but doesn't manage its content in any way, this is the responsibility of the test code",
pub(crate) fn complete_cargo_env_vars(
    CARGO_DEFINED_VARS.iter().for_each(|&(var, detail)| {
            "CARGO_BIN_NAME",
    let foo = env!("CARGO_BIN_NAME");
            "CARGO_BIN_NAME",
    let foo = option_env!("CARGO_BIN_NAME");
./vendor/rust-analyzer/crates/ide-completion/src/completions/env_vars.rs
    // Unfortunately, binary modules support is in cargo not rustc,
./vendor/rust-analyzer/crates/ide-completion/src/completions/mod_.rs
                completions::env_vars::complete_cargo_env_vars(acc, ctx, original, expanded);
./vendor/rust-analyzer/crates/ide-completion/src/lib.rs
//! Generated by `cargo codegen lint-definitions`, do not edit by hand.
with `cargo check`) as an alternative to `rustc -Z print-type-sizes`
We can run benchmark tests with `cargo bench`:
$ cargo bench
Our non-benchmark test was ignored. You may have noticed that `cargo bench`
takes a bit longer than `cargo test`. This is because Rust runs our benchmark
The `cargo build` output:
        label: "clippy::cargo_common_metadata",
`Cargo.toml`. See: https://rust-lang-nursery.github.io/api-guidelines/documentation.html#cargotoml-includes-all-common-metadata-c-metadata"##,
        description: r##"Checks for `#[cfg_attr(feature = cargo-clippy, ...)]` and for
`#[cfg(feature = cargo-clippy)]` and suggests to replace it with
        description: r##"Checks for lint groups with the same priority as lints in the `Cargo.toml`
[`[lints]` table](https://doc.rust-lang.org/cargo/reference/manifest.html#the-lints-section).
This lint will be removed once [cargo#12918](https://github.com/rust-lang/cargo/issues/12918)
        description: r##"Checks for wildcard dependencies in the `Cargo.toml`."##,
            label: "clippy::cargo",
            description: r##"lint group for: clippy::cargo_common_metadata, clippy::multiple_crate_versions, clippy::negative_feature_names, clippy::redundant_feature_names, clippy::wildcard_dependencies"##,
            "clippy::cargo_common_metadata",
./vendor/rust-analyzer/crates/ide-db/src/generated/lints.rs
        // finished startup, or we couldn't find the Cargo.toml.
./vendor/rust-analyzer/crates/ide-diagnostics/src/handlers/unlinked_file.rs
                // FIXME: We can make this configurable, and if the user uses `cargo clippy` on flycheck, we can
./vendor/rust-analyzer/crates/ide-diagnostics/src/lib.rs
                            // `rust-analyzer cargo foo . bar/` over `rust-analyzer cargo foo . crate/bar/`
./vendor/rust-analyzer/crates/ide/src/moniker.rs
//! Loads a Cargo project into a static instance of analysis, without support
use project_model::{CargoConfig, PackageRoot, ProjectManifest, ProjectWorkspace};
pub struct LoadCargoConfig {
    cargo_config: &CargoConfig,
    load_config: &LoadCargoConfig,
    let mut workspace = ProjectWorkspace::load(root, cargo_config, progress)?;
        let build_scripts = workspace.run_build_scripts(cargo_config, progress)?;
    load_workspace(workspace, &cargo_config.extra_env, load_config)
    load_config: &LoadCargoConfig,
    load_config: &LoadCargoConfig,
    tracing::debug!(?load_config, "LoadCargoConfig");
        // PackageRoot { is_local: false, include: [AbsPathBuf(".../rust/src/tools/miri/cargo-miri")], exclude: [] }
        //     include: [AbsPathBuf(".../rust/src/tools/miri/cargo-miri"), AbsPathBuf(".../rust/build/x86_64-pc-windows-msvc/stage0-tools/x86_64-pc-windows-msvc/release/build/cargo-miri-85801cd3d2d1dae4/out")],
        //     exclude: [AbsPathBuf(".../rust/src/tools/miri/cargo-miri/.git"), AbsPathBuf(".../rust/src/tools/miri/cargo-miri/target")]
                    tracing::info_span!("load_cargo::load_crate_craph/LoadedChanged").entered();
        let path = Path::new(env!("CARGO_MANIFEST_DIR")).parent().unwrap().parent().unwrap();
        let cargo_config = CargoConfig { set_test: true, ..CargoConfig::default() };
        let load_cargo_config = LoadCargoConfig {
            load_workspace_at(path, &cargo_config, &load_cargo_config, &|_| {}).unwrap();
./vendor/rust-analyzer/crates/load-cargo/src/lib.rs
//! After adding a new inline-test, run `cargo test -p xtask` to
//! `crates/syntax/test_data/parser/`, and run `cargo test` once to
./vendor/rust-analyzer/crates/parser/src/grammar.rs
//! Generated by `cargo xtask codegen grammar`, do not edit by hand.
./vendor/rust-analyzer/crates/parser/src/syntax_kind/generated.rs
        let crate_root_dir = Path::new(env!("CARGO_MANIFEST_DIR"));
./vendor/rust-analyzer/crates/parser/src/tests.rs
/// Taken from <https://github.com/rust-lang/cargo/blob/79c769c3d7b4c2cf6a93781575b7f592ef974255/src/cargo/util/paths.rs#L60-L85>
./vendor/rust-analyzer/crates/paths/src/lib.rs
//! as we don't have bincode in Cargo.toml yet, lets stick with serde_json for
./vendor/rust-analyzer/crates/proc-macro-api/src/legacy_protocol/msg/flat.rs
    println!("cargo::rustc-check-cfg=cfg(rust_analyzer)");
    println!("cargo:rerun-if-env-changed=CFG_RELEASE");
        env::var("CARGO_MANIFEST_DIR").expect("`CARGO_MANIFEST_DIR` is always set by cargo."),
            println!("cargo:rerun-if-changed={}", head_ref.display());
    println!("cargo:warning=Could not find `.git/HEAD` from manifest dir!");
    println!("cargo:rustc-env=RA_COMMIT_HASH={}", next());
    println!("cargo:rustc-env=RA_COMMIT_SHORT_HASH={}", next());
    println!("cargo:rustc-env=RA_COMMIT_DATE={}", next())
./vendor/rust-analyzer/crates/proc-macro-srv-cli/build.rs
/// Cargo's version.
/// Returns information about cargo's version.
./vendor/rust-analyzer/crates/proc-macro-srv-cli/src/version.rs
    println!("cargo::rustc-check-cfg=cfg(rust_analyzer)");
    println!("cargo::rustc-env=RUSTC_VERSION={version_string}");
./vendor/rust-analyzer/crates/proc-macro-srv/build.rs
use cargo_metadata::Message;
    println!("cargo:rerun-if-changed=imp");
    let cargo = env::var_os("CARGO").unwrap_or_else(|| "cargo".into());
        || String::from_utf8(Command::new(&cargo).arg("--version").output().unwrap().stdout)
        println!("cargo::rustc-env=PROC_MACRO_TEST_LOCATION=\"\"");
    for item_els in [&["Cargo.toml"][..], &["build.rs"][..], &["src", "lib.rs"]] {
    let mut cmd = Command::new(&cargo);
        // cargo is using, or we'll deadlock.
        // This can happen when `CARGO_TARGET_DIR` is set or global config forces all cargo
    // New Package Id Spec since rust-lang/cargo#13311
        Command::new(cargo)
            && artifact.target.kind.contains(&cargo_metadata::TargetKind::ProcMacro)
    println!("cargo::rustc-env=PROC_MACRO_TEST_LOCATION={}", artifact_path.display());
./vendor/rust-analyzer/crates/proc-macro-srv/proc-macro-test/build.rs
//! This teaches cargo about our cfg(rust_analyzer)
    println!("cargo:rustc-check-cfg=cfg(rust_analyzer)");
./vendor/rust-analyzer/crates/proc-macro-srv/proc-macro-test/imp/build.rs
/// $ nix-shell --run 'cargo test --release --package rust-analyzer --lib -- benchmarks::benchmark_integrated_highlighting --exact --nocapture'
            r#"cpu profiling is disabled, uncomment `default = [ "cpu_profiler" ]` in Cargo.toml to enable."#
./vendor/rust-analyzer/crates/profile/src/lib.rs
//! Logic to invoke `cargo` for building build-dependencies (build scripts and proc-macros) as well as
//! In essence this just invokes `cargo` with the appropriate output format which we consume,
use cargo_metadata::{Message, camino::Utf8Path};
    CargoConfig, CargoFeatures, CargoWorkspace, InvocationStrategy, ManifestPath, Package, Sysroot,
    TargetKind, cargo_config_file::make_lockfile_copy,
    cargo_workspace::MINIMUM_TOOLCHAIN_VERSION_SUPPORTING_LOCKFILE_PATH, utf8_stdout,
    /// List of cargo-related environment variables with their value.
        config: &CargoConfig,
        workspace: &CargoWorkspace,
        config: &CargoConfig,
        workspaces: &[&CargoWorkspace],
        // NB: Cargo.toml could have been modified between `cargo metadata` and
        // `cargo check`. We shouldn't assume that package ids we see here are
        rustc: &CargoWorkspace,
                let mut cargo_config = sysroot.tool(Tool::Cargo, current_dir, extra_env);
                cargo_config
                if let Ok(it) = utf8_stdout(&mut cargo_config) {
        workspace: &CargoWorkspace,
        // NB: Cargo.toml could have been modified between `cargo metadata` and
        // `cargo check`. We shouldn't assume that package ids we see here are
                // Copy-pasted from existing cargo_metadata. It seems like we
                                                "invalid cfg from cargo-metadata: {err}"
                            // cargo_metadata crate returns default (empty) path for
                            // older cargos, which is not absolute, so work around that.
                                // inject_cargo_env(package, package_build_data);
                                    .contains(&cargo_metadata::TargetKind::ProcMacro)
            Some(if errors.is_empty() { "cargo check failed".to_owned() } else { errors })
        config: &CargoConfig,
                let mut cmd = sysroot.tool(Tool::Cargo, current_dir, &config.extra_env);
                    CargoFeatures::All => {
                    CargoFeatures::Selected { features, no_default_features } => {
                // If [`--compile-time-deps` flag](https://github.com/rust-lang/cargo/issues/14434) is
                // available in current toolchain's cargo, use it to build compile time deps only.
                let cargo_comp_time_deps_available =
                if cargo_comp_time_deps_available {
                        // `cargo check`.
                    cmd.env("__CARGO_TEST_CHANNEL_OVERRIDE_DO_NOT_USE_THIS", "nightly");
./vendor/rust-analyzer/crates/project-model/src/build_dependencies.rs
//! Read `.cargo/config.toml` as a JSON object
pub(crate) type CargoConfigFile = serde_json::Map<String, serde_json::Value>;
) -> Option<CargoConfigFile> {
    let mut cargo_config = sysroot.tool(Tool::Cargo, manifest.parent(), extra_env);
    cargo_config
        cargo_config.arg("-Zscript");
    tracing::debug!("Discovering cargo config by {:?}", cargo_config);
    let json: serde_json::Map<String, serde_json::Value> = utf8_stdout(&mut cargo_config)
            tracing::debug!("Discovered cargo config: {:?}", json);
            tracing::debug!("Failed to discover cargo config: {:?}", err);
    let target_lockfile = temp_dir.path().join("Cargo.lock").try_into().ok()?;
./vendor/rust-analyzer/crates/project-model/src/cargo_config_file.rs
//! See [`CargoWorkspace`].
use cargo_metadata::{CargoOpt, MetadataCommand};
use crate::cargo_config_file::make_lockfile_copy;
/// [`CargoWorkspace`] represents the logical structure of, well, a Cargo
/// workspace. It pretty closely mirrors `cargo metadata` output.
/// while this knows about `Packages` & `Targets`: purely cargo-related
/// We use absolute paths here, `cargo metadata` guarantees to always produce
pub struct CargoWorkspace {
    /// Environment variables set in the `.cargo/config` file.
impl ops::Index<Package> for CargoWorkspace {
impl ops::Index<Target> for CargoWorkspace {
pub enum CargoFeatures {
impl Default for CargoFeatures {
        CargoFeatures::Selected { features: vec![], no_default_features: false }
pub struct CargoConfig {
    /// Whether to pass `--all-targets` to cargo invocations.
    pub features: CargoFeatures,
    /// Invoke `cargo check` through the RUSTC_WRAPPER.
    /// The command to run instead of `cargo check` for building build scripts.
    /// Extra args to pass to the cargo command.
    /// Extra env vars to set when invoking the cargo command
/// Information associated with a cargo crate
    /// Version given in the `Cargo.toml`
    /// Name as given in the `Cargo.toml`
    /// Repository as given in the `Cargo.toml`
    /// Path containing the `Cargo.toml`
    /// Authors as given in the `Cargo.toml`
    /// Description as given in the `Cargo.toml`
    /// Homepage as given in the `Cargo.toml`
    /// License as given in the `Cargo.toml`
    /// License file as given in the `Cargo.toml`
    /// Readme file as given in the `Cargo.toml`
    /// Rust version as given in the `Cargo.toml`
    fn iter(list: &[cargo_metadata::DepKindInfo]) -> impl Iterator<Item = Self> {
                cargo_metadata::DependencyKind::Normal => dep_kinds[0] = Some(Self::Normal),
                cargo_metadata::DependencyKind::Development => dep_kinds[1] = Some(Self::Dev),
                cargo_metadata::DependencyKind::Build => dep_kinds[2] = Some(Self::Build),
                cargo_metadata::DependencyKind::Unknown => continue,
    /// Name as given in the `Cargo.toml` or generated from the file name
    /// Any kind of Cargo lib crate-type (dylib, rlib, proc-macro, ...).
    /// Cargo calls this kind `custom-build`
    pub fn new(kinds: &[cargo_metadata::TargetKind]) -> TargetKind {
                cargo_metadata::TargetKind::Bin => TargetKind::Bin,
                cargo_metadata::TargetKind::Test => TargetKind::Test,
                cargo_metadata::TargetKind::Bench => TargetKind::Bench,
                cargo_metadata::TargetKind::Example => TargetKind::Example,
                cargo_metadata::TargetKind::CustomBuild => TargetKind::BuildScript,
                cargo_metadata::TargetKind::ProcMacro => TargetKind::Lib { is_proc_macro: true },
                cargo_metadata::TargetKind::Lib
                | cargo_metadata::TargetKind::DyLib
                | cargo_metadata::TargetKind::CDyLib
                | cargo_metadata::TargetKind::StaticLib
                | cargo_metadata::TargetKind::RLib => TargetKind::Lib { is_proc_macro: false },
    /// If this is a valid cargo target, returns the name cargo uses in command line arguments
    /// https://docs.rs/cargo_metadata/latest/cargo_metadata/enum.TargetKind.html
    pub fn as_cargo_target(self) -> Option<&'static str> {
pub struct CargoMetadataConfig {
    pub features: CargoFeatures,
    /// Extra args to pass to the cargo command.
    /// Extra env vars to set when invoking the cargo command
    /// Used to conditionally enable unstable cargo features.
// Deserialize helper for the cargo metadata
impl CargoWorkspace {
        mut meta: cargo_metadata::Metadata,
        cargo_config_env: Env,
    ) -> CargoWorkspace {
            let cargo_metadata::Package {
                cargo_metadata::Edition::E2015 => Edition::Edition2015,
                cargo_metadata::Edition::E2018 => Edition::Edition2018,
                cargo_metadata::Edition::E2021 => Edition::Edition2021,
                cargo_metadata::Edition::E2024 => Edition::Edition2024,
                let cargo_metadata::Target { name, kind, required_features, src_path, .. } =
                        // cargo strips the script part of a cargo script away and places the
        CargoWorkspace {
            config_env: cargo_config_env,
        // this pkg is inside this cargo workspace, fallback to workspace root
                ManifestPath::try_from(self.workspace_root().join("Cargo.toml")).ok()?,
    command: cargo_metadata::MetadataCommand,
    no_deps_result: anyhow::Result<cargo_metadata::Metadata>,
    /// Builds a command to fetch metadata for the given `cargo_toml` manifest.
    /// environment variable when invoking Cargo, ensuring that the
        cargo_toml: &ManifestPath,
        config: &CargoMetadataConfig,
        let cargo = sysroot.tool(Tool::Cargo, current_dir, &config.extra_env);
        command.cargo_path(cargo.get_program());
        cargo.get_envs().for_each(|(var, val)| _ = command.env(var, val.unwrap_or_default()));
        command.manifest_path(cargo_toml.to_path_buf());
            CargoFeatures::All => {
                command.features(CargoOpt::AllFeatures);
            CargoFeatures::Selected { features, no_default_features } => {
                    command.features(CargoOpt::NoDefaultFeatures);
                    command.features(CargoOpt::SomeFeatures(features.clone()));
        // cargo metadata only supports a subset of flags of what cargo usually accepts, and usually
        if cargo_toml.is_rust_manifest() {
            lockfile_path = Some(<_ as AsRef<Utf8Path>>::as_ref(cargo_toml).with_extension("lock"));
        let cargo_command;
            cargo_command = command.cargo_command();
            cargo_command = no_deps_command.cargo_command();
        .with_context(|| format!("Failed to run `{cargo_command:?}`"));
            manifest_path: cargo_toml.clone(),
    pub(crate) fn no_deps_metadata(&self) -> Option<&cargo_metadata::Metadata> {
    ) -> anyhow::Result<(cargo_metadata::Metadata, Option<anyhow::Error>)> {
            command.env("__CARGO_TEST_CHANNEL_OVERRIDE_DO_NOT_USE_THIS", "nightly");
        // This way cargo cannot error out on us if the lockfile requires updating.
        progress("cargo metadata: started".to_owned());
            tracing::debug!("Running `{:?}`", command.cargo_command());
                spawn_with_streaming_output(command.cargo_command(), &mut |_| (), &mut |line| {
                        progress("cargo metadata: ?".to_owned());
                    progress(format!("cargo metadata: {line}"));
                progress(format!("cargo metadata: failed {}", output.status));
                let error = cargo_metadata::Error::CargoMetadata {
                            "`cargo metadata` failed and returning succeeded result with `--no-deps`"
                .ok_or(cargo_metadata::Error::NoJson)?;
            Ok((cargo_metadata::MetadataCommand::parse(stdout)?, None))
        .with_context(|| format!("Failed to run `{:?}`", command.cargo_command()));
        progress("cargo metadata: finished".to_owned());
./vendor/rust-analyzer/crates/project-model/src/cargo_workspace.rs
//! Cargo-like environment variables injection.
use crate::{ManifestPath, PackageData, TargetKind, cargo_config_file::CargoConfigFile};
/// Recreates the compile-time environment variables that Cargo sets.
/// <https://doc.rust-lang.org/cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-crates>
/// FIXME: ask Cargo to provide this data instead of re-deriving.
pub(crate) fn inject_cargo_package_env(env: &mut Env, package: &PackageData) {
    // CARGO_BIN_NAME, CARGO_BIN_EXE_<name>
    env.set("CARGO_MANIFEST_DIR", manifest_dir.as_str());
    env.set("CARGO_MANIFEST_PATH", package.manifest.as_str());
    env.set("CARGO_PKG_VERSION", package.version.to_string());
    env.set("CARGO_PKG_VERSION_MAJOR", package.version.major.to_string());
    env.set("CARGO_PKG_VERSION_MINOR", package.version.minor.to_string());
    env.set("CARGO_PKG_VERSION_PATCH", package.version.patch.to_string());
    env.set("CARGO_PKG_VERSION_PRE", package.version.pre.to_string());
    env.set("CARGO_PKG_AUTHORS", package.authors.join(":"));
    env.set("CARGO_PKG_NAME", package.name.clone());
    env.set("CARGO_PKG_DESCRIPTION", package.description.as_deref().unwrap_or_default());
    env.set("CARGO_PKG_HOMEPAGE", package.homepage.as_deref().unwrap_or_default());
    env.set("CARGO_PKG_REPOSITORY", package.repository.as_deref().unwrap_or_default());
    env.set("CARGO_PKG_LICENSE", package.license.as_deref().unwrap_or_default());
        "CARGO_PKG_LICENSE_FILE",
        "CARGO_PKG_README",
        "CARGO_PKG_RUST_VERSION",
pub(crate) fn inject_cargo_env(env: &mut Env) {
    env.set("CARGO", Tool::Cargo.path().to_string());
pub(crate) fn inject_rustc_tool_env(env: &mut Env, cargo_name: &str, kind: TargetKind) {
    //     env.set("CARGO_BIN_NAME", cargo_name);
    env.set("CARGO_CRATE_NAME", cargo_name.replace('-', "_"));
pub(crate) fn cargo_config_env(manifest: &ManifestPath, config: &Option<CargoConfigFile>) -> Env {
    // FIXME: The base here should be the parent of the `.cargo/config` file, not the manifest.
    // But cargo does not provide this information.
fn parse_output_cargo_config_env_works() {
    "CARGO_WORKSPACE_DIR": {
    let config: CargoConfigFile = serde_json::from_str(raw).unwrap();
    let manifest = paths::AbsPathBuf::assert(cwd.join("Cargo.toml"));
    let env = cargo_config_env(&manifest, &Some(config));
    assert_eq!(env.get("CARGO_WORKSPACE_DIR").as_deref(), Some(cwd.join("").as_str()));
./vendor/rust-analyzer/crates/project-model/src/env.rs
//! Specifically, here we have a representation for a Cargo project
//! ([`CargoWorkspace`]) and for manually specified layout ([`ProjectJson`]).
//! * Project discovery (where's the relevant Cargo.toml for the current dir).
    use crate::{ManifestPath, Sysroot, cargo_config_file::CargoConfigFile};
        /// Attempt to use cargo to query the desired information, honoring cargo configurations.
        Cargo(&'a Sysroot, &'a ManifestPath, &'a Option<CargoConfigFile>),
mod cargo_config_file;
mod cargo_workspace;
    cargo_workspace::{
        CargoConfig, CargoFeatures, CargoMetadataConfig, CargoWorkspace, Package, PackageData,
pub use cargo_metadata::Metadata;
    CargoToml(ManifestPath),
    CargoScript(ManifestPath),
        if path.file_name().unwrap_or_default() == "Cargo.toml" {
            return Ok(ProjectManifest::CargoToml(path));
            return Ok(ProjectManifest::CargoScript(path));
            "project root must point to a Cargo.toml, rust-project.json or <script>.rs file: {path}"
        return find_cargo_toml(path)
            .map(|paths| paths.into_iter().map(ProjectManifest::CargoToml).collect());
        fn find_cargo_toml(path: &AbsPath) -> io::Result<Vec<ManifestPath>> {
            match find_in_parent_dirs(path, "Cargo.toml") {
                None => Ok(find_cargo_toml_in_child_dir(read_dir(path)?)),
        fn find_cargo_toml_in_child_dir(entities: ReadDir) -> Vec<ManifestPath> {
                .map(|it| it.path().join("Cargo.toml"))
            | ProjectManifest::CargoToml(it)
            | ProjectManifest::CargoScript(it) => it,
    CargoMetadata(CargoMetadataConfig),
        RustSourceWorkspaceConfig::default_cargo()
    pub fn default_cargo() -> Self {
        RustSourceWorkspaceConfig::CargoMetadata(Default::default())
./vendor/rust-analyzer/crates/project-model/src/lib.rs
/// We use it to store path to Cargo.toml, as we frequently use the parent dir
./vendor/rust-analyzer/crates/project-model/src/manifest_path.rs
//! idea here is that people who do not use Cargo, can instead teach their build
//! Normally, we get this "crate graph" by calling `cargo metadata
//! --message-format=json` for each cargo workspace and merging results. This
//! works for your typical cargo project, but breaks down for large folks who
//! not for convenience (you'd be using cargo anyway if you wanted nice things,
    /// The working directory to run proc-macros in. This is usually the workspace root of cargo workspaces.
    /// For example, this might be `cargo`, `buck`, or `bazel`.
    /// Any kind of Cargo lib crate-type (dylib, rlib, proc-macro, ...).
./vendor/rust-analyzer/crates/project-model/src/project_json.rs
    CargoWorkspace, ManifestPath, ProjectJson, RustSourceWorkspaceConfig,
    cargo_workspace::{CargoMetadataConfig, FetchMetadata},
    Workspace(CargoWorkspace),
    /// Returns a command to run a tool preferring the cargo proxies if the sysroot exists.
                // as it should never invoke another cargo binary
        if let RustSourceWorkspaceConfig::CargoMetadata(cargo_config) = sysroot_source_config {
            let library_manifest = ManifestPath::try_from(src_root.join("Cargo.toml")).unwrap();
                match self.load_library_via_cargo(
                    cargo_config,
                        tracing::error!("`cargo metadata` failed on `{library_manifest}` : {e}")
    fn load_library_via_cargo(
        cargo_config: &CargoMetadataConfig,
        let mut cargo_config = cargo_config.clone();
        // the sysroot uses `public-dependency`, so we make cargo think it's a nightly
        cargo_config.extra_env.insert(
            "__CARGO_TEST_CHANNEL_OVERRIDE_DO_NOT_USE_THIS".to_owned(),
            FetchMetadata::new(library_manifest, current_dir, &cargo_config, self, no_deps)
        let cargo_workspace =
            CargoWorkspace::new(res, library_manifest.clone(), Default::default(), true);
        Ok(RustLibSrcWorkspace::Workspace(cargo_workspace))
    let rustc_src = sysroot_path.join("lib/rustlib/rustc-src/rust/compiler/rustc/Cargo.toml");
./vendor/rust-analyzer/crates/project-model/src/sysroot.rs
use cargo_metadata::Metadata;
    CargoWorkspace, CfgOverrides, ManifestPath, ProjectJson, ProjectJsonData, ProjectWorkspace,
fn load_cargo(file: &str) -> (CrateGraphBuilder, ProcMacroPaths) {
fn load_cargo_with_overrides(
    let cargo_workspace = CargoWorkspace::new(meta, manifest_path, Default::default(), false);
        kind: ProjectWorkspaceKind::Cargo {
            cargo: cargo_workspace,
fn replace_cargo(s: &mut String) {
    let path = toolchain::Tool::Cargo.path().to_string().escape_debug().collect::<String>();
    *s = s.replace(&path, "$CARGO$");
    let base = Utf8PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    replace_cargo(&mut crate_graph);
fn cargo_hello_world_project_model_with_wildcard_overrides() {
        load_cargo_with_overrides("hello-world-metadata.json", cfg_overrides);
            "../test_data/output/cargo_hello_world_project_model_with_wildcard_overrides.txt"
fn cargo_hello_world_project_model_with_selective_overrides() {
        load_cargo_with_overrides("hello-world-metadata.json", cfg_overrides);
            "../test_data/output/cargo_hello_world_project_model_with_selective_overrides.txt"
fn cargo_hello_world_project_model() {
    let (crate_graph, _proc_macros) = load_cargo("hello-world-metadata.json");
        expect_file!["../test_data/output/cargo_hello_world_project_model.txt"],
    let (mut crate_graph, proc_macros) = load_cargo("regex-metadata.json");
fn smoke_test_real_sysroot_cargo() {
    let cargo_workspace = CargoWorkspace::new(meta, manifest_path, Default::default(), false);
        AbsPath::assert(Utf8Path::new(env!("CARGO_MANIFEST_DIR"))),
    let cwd = AbsPathBuf::assert_utf8(temp_dir().join("smoke_test_real_sysroot_cargo"));
        &RustSourceWorkspaceConfig::default_cargo(),
        kind: ProjectWorkspaceKind::Cargo {
            cargo: cargo_workspace,
./vendor/rust-analyzer/crates/project-model/src/tests.rs
        QueryConfig::Cargo(sysroot, cargo_toml, _) => {
            let mut cmd = sysroot.tool(Tool::Cargo, cargo_toml.parent(), extra_env);
            cmd.env("__CARGO_TEST_CHANNEL_OVERRIDE_DO_NOT_USE_THIS", "nightly");
                    (sysroot, cargo_toml.parent().as_ref())
    fn cargo() {
        let manifest_path = concat!(env!("CARGO_MANIFEST_DIR"), "/Cargo.toml");
        let cfg = QueryConfig::Cargo(&sysroot, &manifest_path, &None);
        let cfg = QueryConfig::Rustc(&sysroot, env!("CARGO_MANIFEST_DIR").as_ref());
./vendor/rust-analyzer/crates/project-model/src/toolchain_info/rustc_cfg.rs
        QueryConfig::Cargo(sysroot, cargo_toml, _) => {
            let mut cmd = sysroot.tool(Tool::Cargo, cargo_toml.parent(), extra_env);
                    (sysroot, cargo_toml.parent().as_ref())
    fn cargo() {
        let manifest_path = concat!(env!("CARGO_MANIFEST_DIR"), "/Cargo.toml");
        let cfg = QueryConfig::Cargo(&sysroot, &manifest_path, &None);
        let cfg = QueryConfig::Rustc(&sysroot, env!("CARGO_MANIFEST_DIR").as_ref());
./vendor/rust-analyzer/crates/project-model/src/toolchain_info/target_data_layout.rs
    Sysroot, cargo_config_file::CargoConfigFile, toolchain_info::QueryConfig, utf8_stdout,
/// For cargo, runs `cargo -Zunstable-options config get build.target` to get the configured project target(s).
        QueryConfig::Cargo(sysroot, cargo_toml, config_file) => {
            match config_file.as_ref().and_then(cargo_config_build_target) {
                None => (sysroot, cargo_toml.parent().as_ref()),
fn cargo_config_build_target(config: &CargoConfigFile) -> Option<Vec<String>> {
    match parse_json_cargo_config_build_target(config) {
            tracing::debug!("Failed to discover cargo config build target {e:?}");
fn parse_json_cargo_config_build_target(
    config: &CargoConfigFile,
    fn cargo() {
        let manifest_path = concat!(env!("CARGO_MANIFEST_DIR"), "/Cargo.toml");
        let cfg = QueryConfig::Cargo(&sysroot, &manifest_path, &None);
        let cfg = QueryConfig::Rustc(&sysroot, env!("CARGO_MANIFEST_DIR").as_ref());
./vendor/rust-analyzer/crates/project-model/src/toolchain_info/target_tuple.rs
        QueryConfig::Cargo(sysroot, cargo_toml, _) => {
            (sysroot.tool(Tool::Cargo, cargo_toml.parent(), extra_env), "cargo ")
    fn cargo() {
        let manifest_path = concat!(env!("CARGO_MANIFEST_DIR"), "/Cargo.toml");
        let cfg = QueryConfig::Cargo(&sysroot, &manifest_path, &None);
        let cfg = QueryConfig::Rustc(&sysroot, env!("CARGO_MANIFEST_DIR").as_ref());
./vendor/rust-analyzer/crates/project-model/src/toolchain_info/version.rs
//! Handles lowering of build-system specific workspace information (`cargo
    CargoConfig, CargoWorkspace, CfgOverrides, InvocationStrategy, ManifestPath, Package,
    cargo_config_file,
    cargo_workspace::{CargoMetadataConfig, DepKind, FetchMetadata, PackageData, RustLibSource},
    env::{cargo_config_env, inject_cargo_env, inject_cargo_package_env, inject_rustc_tool_env},
    /// Project workspace was discovered by running `cargo metadata` and `rustc --print sysroot`.
    Cargo {
        /// The workspace as returned by `cargo metadata`.
        cargo: CargoWorkspace,
        /// Additional `cargo metadata` error. (only populated if retried fetching via `--no-deps` succeeded).
        rustc: Result<Box<(CargoWorkspace, WorkspaceBuildScripts)>, Option<String>>,
    // Ideally, you should be able to just open a random detached file in existing cargo projects, and get the basic features working.
        /// Is this file a cargo script file?
        cargo: Option<(CargoWorkspace, WorkspaceBuildScripts, Option<Arc<anyhow::Error>>)>,
            ProjectWorkspaceKind::Cargo { cargo, error: _, build_scripts, rustc } => f
                .debug_struct("Cargo")
                .field("root", &cargo.workspace_root().file_name())
                .field("n_packages", &cargo.packages().len())
            ProjectWorkspaceKind::DetachedFile { file, cargo: cargo_script } => f
                .field("cargo_script", &cargo_script.is_some())
                .field("cargo_script", &cargo_script.is_some())
        config: &CargoConfig,
        config: &CargoConfig,
            ProjectManifest::CargoScript(rust_file) => {
            ProjectManifest::CargoToml(cargo_toml) => {
                ProjectWorkspace::load_cargo(cargo_toml, config, progress)?
    fn load_cargo(
        cargo_toml: &ManifestPath,
        config: &CargoConfig,
        let CargoConfig {
        let workspace_dir = cargo_toml.parent();
        // Resolve the Cargo.toml to the workspace root as we base the `target` dir off of it.
        let mut cmd = sysroot.tool(Tool::Cargo, workspace_dir, extra_env);
        cmd.args(["locate-project", "--workspace", "--manifest-path", cargo_toml.as_str()]);
        let cargo_toml = &match utf8_stdout(&mut cmd) {
                        tracing::error!(%e, %cargo_toml, "failed fetching cargo workspace root");
                        cargo_toml.clone()
                tracing::error!(%e, %cargo_toml, "failed fetching cargo workspace root");
                cargo_toml.clone()
        let workspace_dir = cargo_toml.parent();
        tracing::info!(workspace = %cargo_toml, src_root = ?sysroot.rust_lib_src_root(), root = ?sysroot.root(), "Using sysroot");
        let config_file = cargo_config_file::read(cargo_toml, extra_env, &sysroot);
        let toolchain_config = QueryConfig::Cargo(&sysroot, cargo_toml, &config_file_);
                    "failed fetching toolchain version for {cargo_toml:?} workspace"
            cargo_toml,
            &CargoMetadataConfig {
                    tracing::error!(%e, "failed fetching data layout for {cargo_toml:?} workspace")
                    info!(workspace = %cargo_toml, rustc_dir = %rustc_dir, "Using rustc source");
                        &CargoMetadataConfig {
                            features: crate::CargoFeatures::default(),
                            let workspace = CargoWorkspace::new(
                                cargo_toml.clone(),
                                "Failed to read Cargo metadata from rustc source at {rustc_dir}",
                                "Failed to read Cargo metadata from rustc source at {rustc_dir}: {e}"
            let cargo_metadata = s.spawn(|| fetch_metadata.exec(&target_dir, false, progress));
                    &RustSourceWorkspaceConfig::CargoMetadata(sysroot_metadata_config(
            let cargo_config_extra_env =
                s.spawn(move || cargo_config_env(cargo_toml, &config_file));
                cargo_metadata.join()?,
                cargo_config_extra_env.join()?,
            cargo_metadata,
            cargo_config_extra_env,
        let (meta, error) = cargo_metadata.with_context(|| {
                "Failed to read Cargo metadata from Cargo.toml file {cargo_toml}, {toolchain:?}",
        let cargo = CargoWorkspace::new(meta, cargo_toml.clone(), cargo_config_extra_env, false);
        if !cargo.requires_rustc_private()
            kind: ProjectWorkspaceKind::Cargo {
                cargo,
        config: &CargoConfig,
            .or_else(|| cargo_target_dir(project_json.manifest()?, &config.extra_env, &sysroot))
                        &RustSourceWorkspaceConfig::CargoMetadata(sysroot_metadata_config(
        config: &CargoConfig,
        let config_file = cargo_config_file::read(detached_file, &config.extra_env, &sysroot);
        let query_config = QueryConfig::Cargo(&sysroot, detached_file, &config_file);
            .or_else(|| cargo_target_dir(detached_file, &config.extra_env, &sysroot))
            &RustSourceWorkspaceConfig::CargoMetadata(sysroot_metadata_config(
            &CargoMetadataConfig {
        let cargo_script =
                let cargo_config_extra_env = cargo_config_env(detached_file, &config_file);
                    CargoWorkspace::new(ws, detached_file.clone(), cargo_config_extra_env, false),
                cargo: cargo_script,
        config: &CargoConfig,
        config: &CargoConfig,
            ProjectWorkspaceKind::DetachedFile { cargo: Some((cargo, _, None)), .. }
            | ProjectWorkspaceKind::Cargo { cargo, error: None, .. } => {
                    cargo,
                    format!("Failed to run build scripts for {}", cargo.workspace_root())
        config: &CargoConfig,
        let cargo_ws: Vec<_> = workspaces
                ProjectWorkspaceKind::Cargo { cargo, .. } => Some(cargo),
            &cargo_ws,
                ProjectWorkspaceKind::Cargo { cargo, .. } => match outputs {
                        format!("Failed to run build scripts for {}", cargo.workspace_root())
            ProjectWorkspaceKind::Cargo { build_scripts, .. }
            | ProjectWorkspaceKind::DetachedFile { cargo: Some((_, build_scripts, _)), .. } => {
            ProjectWorkspaceKind::Cargo { cargo, .. } => cargo.manifest_path(),
            ProjectWorkspaceKind::Cargo { cargo, .. } => cargo.workspace_root(),
            ProjectWorkspaceKind::Cargo { cargo, .. } => Some(cargo.manifest_path()),
            ProjectWorkspaceKind::DetachedFile { cargo, .. } => {
                Some(cargo.as_ref()?.0.manifest_path())
            ProjectWorkspaceKind::Cargo { cargo, rustc, build_scripts, error: _ } => {
                cargo
                        let is_local = cargo[pkg].is_local;
                        let pkg_root = cargo[pkg].manifest.parent().to_path_buf();
                        // In case target's path is manually set in Cargo.toml to be
                        let extra_targets = cargo[pkg]
                            .filter(|&&tgt| matches!(cargo[tgt].kind, TargetKind::Lib { .. }))
                            .filter_map(|&tgt| cargo[tgt].root.parent())
            ProjectWorkspaceKind::DetachedFile { file, cargo: cargo_script, .. } => {
                .chain(cargo_script.iter().flat_map(|(cargo, build_scripts, _)| {
                    cargo.packages().map(|pkg| {
                        let is_local = cargo[pkg].is_local;
                        let pkg_root = cargo[pkg].manifest.parent().to_path_buf();
                        // In case target's path is manually set in Cargo.toml to be
                        let extra_targets = cargo[pkg]
                            .filter(|&&tgt| matches!(cargo[tgt].kind, TargetKind::Lib { .. }))
                            .filter_map(|&tgt| cargo[tgt].root.parent())
            ProjectWorkspaceKind::Cargo { cargo, rustc, .. } => {
                cargo.packages().len() + sysroot_package_len + rustc_package_len
            ProjectWorkspaceKind::DetachedFile { cargo: cargo_script, .. } => {
                    + cargo_script.as_ref().map_or(1, |(cargo, _, _)| cargo.packages().len())
            ProjectWorkspaceKind::Cargo { cargo, rustc, build_scripts, error: _ } => {
                cargo_to_crate_graph(
                    cargo,
            ProjectWorkspaceKind::DetachedFile { file, cargo: cargo_script, .. } => {
                if let Some((cargo, build_scripts, _)) = cargo_script {
                    cargo_to_crate_graph(
                        cargo,
                ProjectWorkspaceKind::Cargo { cargo, rustc, build_scripts: _, error: _ },
                ProjectWorkspaceKind::Cargo {
                    cargo: o_cargo,
            ) => cargo == o_cargo && rustc == o_rustc,
                ProjectWorkspaceKind::DetachedFile { file, cargo: Some((cargo_script, _, _)) },
                    cargo: Some((o_cargo_script, _, _)),
            ) => file == o_file && cargo_script == o_cargo_script,
fn cargo_to_crate_graph(
    rustc: Option<&(CargoWorkspace, WorkspaceBuildScripts)>,
    cargo: &CargoWorkspace,
    let _p = tracing::info_span!("cargo_to_crate_graph").entered();
    let workspace_proc_macro_cwd = Arc::new(cargo.workspace_root().to_path_buf());
    for pkg in cargo.packages() {
            if cargo[pkg].is_local {
                if set_test && !cargo.is_sysroot() {
            override_cfg.apply(&mut cfg_options, &cargo[pkg].name);
        for &tgt in cargo[pkg].targets.iter() {
            let pkg_data = &cargo[pkg];
            if !matches!(cargo[tgt].kind, TargetKind::Lib { .. })
                && (!pkg_data.is_member || cargo.is_sysroot())
                // For non-workspace-members, Cargo does not resolve dev-dependencies, so we don't
            let &TargetData { ref name, kind, ref root, .. } = &cargo[tgt];
                cargo,
                    if cargo.is_sysroot() {
                // cargo metadata does not do any normalization,
    for pkg in cargo.packages() {
        for dep in &cargo[pkg].dependencies {
                    && cargo[dep.pkg].is_member
                    && cargo[pkg].is_member
    if cargo.requires_rustc_private() {
                cargo,
                if rustc_workspace.workspace_root() == cargo.workspace_root() {
    rustc_workspace: &CargoWorkspace,
    cargo: &CargoWorkspace,
    let workspace_proc_macro_cwd = Arc::new(cargo.workspace_root().to_path_buf());
            for pkg in cargo.packages() {
                let package = &cargo[pkg];
    cargo: &CargoWorkspace,
    cargo_name: &str,
    let mut env = cargo.env().clone();
    inject_cargo_package_env(&mut env, pkg);
    inject_cargo_env(&mut env);
    inject_rustc_tool_env(&mut env, cargo_name, kind);
        Some(CrateDisplayName::from_canonical_name(cargo_name)),
                    ProcMacroDylibPath::Path(path) => Ok((cargo_name.to_owned(), path.clone())),
        RustLibSrcWorkspace::Workspace(cargo) => {
            let (sysroot_cg, sysroot_pm) = cargo_to_crate_graph(
                cargo,
    config: &CargoConfig,
) -> CargoMetadataConfig {
    CargoMetadataConfig {
fn cargo_target_dir(
    let cargo = sysroot.tool(Tool::Cargo, manifest.parent(), extra_env);
    let mut meta = cargo_metadata::MetadataCommand::new();
    meta.cargo_path(cargo.get_program());
./vendor/rust-analyzer/crates/project-model/src/workspace.rs
    println!("cargo::rustc-check-cfg=cfg(rust_analyzer)");
        println!("cargo:rustc-env=POKE_RA_DEVS=1");
    println!("cargo:rerun-if-env-changed=CFG_RELEASE");
        env::var("CARGO_MANIFEST_DIR").expect("`CARGO_MANIFEST_DIR` is always set by cargo."),
            println!("cargo:rerun-if-changed={}", head_ref.display());
    println!("cargo:warning=Could not find `.git/HEAD` from manifest dir!");
    println!("cargo:rustc-env=RA_COMMIT_HASH={}", next());
    println!("cargo:rustc-env=RA_COMMIT_SHORT_HASH={}", next());
    println!("cargo:rustc-env=RA_COMMIT_DATE={}", next())
./vendor/rust-analyzer/crates/rust-analyzer/build.rs
        // cargo's compilations unnecessarily. https://github.com/rust-lang/rust-analyzer/issues/14683
./vendor/rust-analyzer/crates/rust-analyzer/src/bin/main.rs
//! initial `cargo check`. That way, we avoid checking the actual project, and
    run_rustc_skipping_cargo_checking(rustc, args.collect())
fn run_rustc_skipping_cargo_checking(
    // `CARGO_CFG_TARGET_ARCH` is only set by cargo when executing build scripts
    let not_invoked_by_build_script = std::env::var_os("CARGO_CFG_TARGET_ARCH").is_none();
    let is_cargo_check = args.iter().any(|arg| {
        // `cargo check` invokes `rustc` with `--emit=metadata` argument.
    if not_invoked_by_build_script && is_cargo_check {
./vendor/rust-analyzer/crates/rust-analyzer/src/bin/rustc_wrapper.rs
use load_cargo::{LoadCargoConfig, ProcMacroServerChoice, load_workspace};
use project_model::{CargoConfig, CfgOverrides, ProjectManifest, ProjectWorkspace, RustLibSource};
        let cargo_config = CargoConfig {
        let mut workspace = ProjectWorkspace::load(manifest, &cargo_config, no_progress)?;
        let load_cargo_config = LoadCargoConfig {
            let bs = workspace.run_build_scripts(&cargo_config, no_progress)?;
            load_workspace(workspace.clone(), &cargo_config.extra_env, &load_cargo_config)?;
        let cargo_config = CargoConfig {
                        let res = ws.run_build_scripts(&cargo_config, &|_| ()).unwrap();
./vendor/rust-analyzer/crates/rust-analyzer/src/cli/analysis_stats.rs
use project_model::{CargoConfig, RustLibSource};
use load_cargo::{LoadCargoConfig, ProcMacroServerChoice, load_workspace_at};
        let cargo_config = CargoConfig {
        let load_cargo_config = LoadCargoConfig {
            load_workspace_at(&self.path, &cargo_config, &load_cargo_config, &|_| {})?;
./vendor/rust-analyzer/crates/rust-analyzer/src/cli/diagnostics.rs
            /// Directory with Cargo.toml or rust-project.json.
            /// Don't run build scripts or load `OUT_DIR` values by running `cargo check` before analysis.
            /// Validate term search by running `cargo check` on every response.
            /// Directory with Cargo.toml or rust-project.json.
            /// Directory with Cargo.toml.
            /// Directory with Cargo.toml or rust-project.json.
            /// Don't run build scripts or load `OUT_DIR` values by running `cargo check` before analysis.
            /// Directory with Cargo.toml or rust-project.json.
            /// Don't run build scripts or load `OUT_DIR` values by running `cargo check` before analysis.
            /// Directory with Cargo.toml or rust-project.json.
            /// Don't run build scripts or load `OUT_DIR` values by running `cargo check` before analysis.
            /// A path to an json configuration file that can be used to customize cargo behavior.
// Run `env UPDATE_XFLAGS=1 cargo build` to regenerate.
./vendor/rust-analyzer/crates/rust-analyzer/src/cli/flags.rs
use load_cargo::{LoadCargoConfig, ProcMacroServerChoice, load_workspace};
use project_model::{CargoConfig, ProjectManifest, ProjectWorkspace, RustLibSource};
                manager: "cargo".to_owned(),
        let cargo_config =
            &CargoConfig { sysroot, all_targets: true, set_test: true, ..Default::default() };
        let load_cargo_config = LoadCargoConfig {
        let mut workspace = ProjectWorkspace::load(root, cargo_config, no_progress)?;
        let build_scripts = workspace.run_build_scripts(cargo_config, no_progress)?;
            load_workspace(workspace, &cargo_config.extra_env, &load_cargo_config)?;
./vendor/rust-analyzer/crates/rust-analyzer/src/cli/lsif.rs
use load_cargo::{LoadCargoConfig, ProcMacroServerChoice, load_workspace};
        let cargo_config = config.cargo(None);
        let load_cargo_config = LoadCargoConfig {
        let workspace = ProjectWorkspace::load(root, &cargo_config, &|_| {})?;
        let (db, _, _) = load_workspace(workspace, &cargo_config.extra_env, &load_cargo_config)?;
./vendor/rust-analyzer/crates/rust-analyzer/src/cli/prime_caches.rs
//! Run all tests in a project, similar to `cargo test`, but using the mir interpreter.
use project_model::{CargoConfig, RustLibSource};
use load_cargo::{LoadCargoConfig, ProcMacroServerChoice, load_workspace_at};
        let cargo_config = CargoConfig {
        let load_cargo_config = LoadCargoConfig {
            load_workspace_at(&self.path, &cargo_config, &load_cargo_config, &|_| {})?;
./vendor/rust-analyzer/crates/rust-analyzer/src/cli/run_tests.rs
//! Run all tests in a project, similar to `cargo test`, but using the mir interpreter.
    CargoConfig, ManifestPath, ProjectWorkspace, ProjectWorkspaceKind, RustLibSource,
use load_cargo::{LoadCargoConfig, ProcMacroServerChoice, load_workspace};
        let cargo_config = CargoConfig {
        let mut sysroot = Sysroot::discover(tmp_file.parent().unwrap(), &cargo_config.extra_env);
            &RustSourceWorkspaceConfig::default_cargo(),
            &cargo_config.extra_env,
                cargo: None,
        let load_cargo_config = LoadCargoConfig {
            load_workspace(workspace, &cargo_config.extra_env, &load_cargo_config)?;
./vendor/rust-analyzer/crates/rust-analyzer/src/cli/rustc_tests.rs
use load_cargo::{LoadCargoConfig, ProcMacroServerChoice, load_workspace_at};
        let load_cargo_config = LoadCargoConfig {
        let cargo_config = config.cargo(None);
            &cargo_config,
            &load_cargo_config,
            manager: "cargo".to_owned(),
            "rust-analyzer cargo foo 0.1.0 example_mod/func().",
            "rust-analyzer cargo foo 0.1.0 module/MyTrait#func().",
            "rust-analyzer cargo foo 0.1.0 module/MyTraitAlias#",
            "rust-analyzer cargo foo 0.1.0 module/MyTrait#MY_CONST.",
            "rust-analyzer cargo foo 0.1.0 module/MyTrait#MyType#",
            "rust-analyzer cargo foo 0.1.0 module/impl#[MyStruct][MyTrait]func().",
            "rust-analyzer cargo foo 0.1.0 St#a.",
            "local enclosed by rust-analyzer cargo foo 0.1.0 example_mod/func().",
            "local enclosed by rust-analyzer cargo foo 0.1.0 example_mod/func().",
            "local enclosed by rust-analyzer cargo foo 0.1.0 module/func().",
            "rust-analyzer cargo main . foo/Bar#",
            "rust-analyzer cargo main . foo/Bar#",
            "rust-analyzer cargo main . MyTypeAlias#",
            "rust-analyzer cargo main . inner_func().",
            // "local enclosed by rust-analyzer cargo main . func().",
            "rust-analyzer cargo main . SomeStruct#",
            // "local enclosed by rust-analyzer cargo main . func().",
            "rust-analyzer cargo main . SOME_CONST.",
            // "local enclosed by rust-analyzer cargo main . func().",
            "rust-analyzer cargo main . SOME_STATIC.",
            // "local enclosed by rust-analyzer cargo main . func().",
./vendor/rust-analyzer/crates/rust-analyzer/src/cli/scip.rs
use load_cargo::{LoadCargoConfig, ProcMacroServerChoice, load_workspace_at};
use project_model::{CargoConfig, RustLibSource};
        let cargo_config = CargoConfig {
        let load_cargo_config = LoadCargoConfig {
            &cargo_config,
            &load_cargo_config,
        let cargo_config =
            CargoConfig { all_targets: true, set_test: true, ..CargoConfig::default() };
        let load_cargo_config = LoadCargoConfig {
            &cargo_config,
            &load_cargo_config,
./vendor/rust-analyzer/crates/rust-analyzer/src/cli/ssr.rs
use load_cargo::{LoadCargoConfig, ProcMacroServerChoice, load_workspace_at};
        let cargo_config = config.cargo(None);
        let load_cargo_config = LoadCargoConfig {
            load_workspace_at(&self.path, &cargo_config, &load_cargo_config, &|_| {})?;
./vendor/rust-analyzer/crates/rust-analyzer/src/cli/unresolved_references.rs
//! Utilities for running a cargo command like `cargo check` or `cargo test` in a separate thread
/// Cargo output is structured as one JSON per line. This trait abstracts parsing one line of
/// cargo output into a Rust data type
pub(crate) trait CargoParser<T>: Send + 'static {
struct CargoActor<T> {
    parser: Box<dyn CargoParser<T>>,
impl<T: Sized + Send + 'static> CargoActor<T> {
        parser: impl CargoParser<T>,
        CargoActor { parser, sender, stdout, stderr }
impl<T: Sized + Send + 'static> CargoActor<T> {
        // Because cargo only outputs one JSON object per line, we can
            // Try to deserialize a message from Cargo or Rustc.
/// A handle to a cargo process used for fly-checking.
    /// The handle to the actual cargo process. As we cannot cancel directly from with
        parser: impl CargoParser<T>,
        let actor = CargoActor::<T>::new(parser, sender, stdout, stderr);
                "Cargo watcher failed, the command produced no valid metadata (exit code: {exit_status:?}):\n{error}"
./vendor/rust-analyzer/crates/rust-analyzer/src/command.rs
    CargoConfig, CargoFeatures, ProjectJson, ProjectJsonData, ProjectJsonFromCommand,
    flycheck::{CargoOptions, FlycheckConfig},
// `package.json` config from this. Run `cargo test` to re-generate that file.
        /// Elements must be paths pointing to `Cargo.toml`, `rust-project.json`, `.rs` files (which
        /// Show `can't find Cargo.toml` error message.
        notifications_cargoTomlNotFound: bool = true,
        /// Enable support for procedural macros, implies `#rust-analyzer.cargo.buildScripts.enable#`.
        ///     // the file used by a non-Cargo build system to define
        /// Pass `--all-targets` to cargo invocation.
        cargo_allTargets: bool           = true,
        /// Automatically refresh project info via `cargo metadata` on
        /// `Cargo.toml` or `.cargo/config.toml` changes.
        cargo_autoreload: bool           = true,
        cargo_buildScripts_enable: bool  = true,
        /// This config only has an effect when `#rust-analyzer.cargo.buildScripts.overrideCommand#`
        cargo_buildScripts_invocationStrategy: InvocationStrategy = InvocationStrategy::PerWorkspace,
        /// (i.e., the folder containing the `Cargo.toml`). This can be overwritten
        /// by changing `#rust-analyzer.cargo.buildScripts.invocationStrategy#`.
        /// By default, a cargo invocation will be constructed for the configured
        /// cargo check --quiet --workspace --message-format=json --all-targets --keep-going
        cargo_buildScripts_overrideCommand: Option<Vec<String>> = None,
        cargo_buildScripts_rebuildOnSave: bool = true,
        cargo_buildScripts_useRustcWrapper: bool = true,
        cargo_cfgs: Vec<String> = {
        /// Extra arguments that are passed to every cargo invocation.
        cargo_extraArgs: Vec<String> = vec![],
        /// Extra environment variables that will be set when running cargo, rustc
        cargo_extraEnv: FxHashMap<String, Option<String>> = FxHashMap::default(),
        /// Set this to `"all"` to pass `--all-features` to cargo.
        cargo_features: CargoFeaturesDef      = CargoFeaturesDef::Selected(vec![]),
        /// Whether to pass `--no-default-features` to cargo.
        cargo_noDefaultFeatures: bool    = false,
        /// entirely offline, and Cargo metadata for dependencies is not fetched.
        cargo_noDeps: bool = false,
        cargo_sysroot: Option<String>    = Some("discover".to_owned()),
        /// `{cargo.sysroot}/lib/rustlib/src/rust/library`.
        cargo_sysrootSrc: Option<String>    = None,
        cargo_target: Option<String>     = None,
        /// This prevents rust-analyzer's `cargo check` and initial build-script and proc-macro
        /// building from locking the `Cargo.lock` at the expense of duplicating build artifacts.
        cargo_targetDir | rust_analyzerTargetDir: Option<TargetDirectory> = None,
        /// `#rust-analyzer.cargo.allTargets#`.
        /// Cargo command to use for `cargo check`.
        /// Extra arguments for `cargo check`.
        /// Extra environment variables that will be set when running `cargo check`.
        /// Extends `#rust-analyzer.cargo.extraEnv#`.
        /// `#rust-analyzer.cargo.features#`.
        /// Set to `"all"` to pass `--all-features` to Cargo.
        check_features | checkOnSave_features: Option<CargoFeaturesDef>  = None,
        /// List of `cargo check` (or other command specified in `check.command`) diagnostics to ignore.
        /// For example for `cargo check`: `dead_code`, `unused_imports`, `unused_variables`,...
        /// Whether to pass `--no-default-features` to Cargo. Defaults to
        /// `#rust-analyzer.cargo.noDefaultFeatures#`.
        /// Override the command rust-analyzer uses instead of `cargo check` for
        /// Cargo, you might also want to change
        /// `#rust-analyzer.cargo.buildScripts.overrideCommand#`.
        /// (i.e., the folder containing the `Cargo.toml`). This can be overwritten
        /// intended to be used with non-Cargo build systems.
        /// cargo check --workspace --message-format=json --all-targets
        /// Check for specific targets. Defaults to `#rust-analyzer.cargo.target#` if empty.
        /// Whether `--workspace` should be passed to `cargo check`.
        /// Command to be executed instead of 'cargo' for runnables.
        /// Additional arguments to be passed to cargo for runnables such as
        /// Additional arguments to be passed through Cargo to launched tests, benchmarks, or
        /// [custom test harness](https://doc.rust-lang.org/cargo/reference/cargo-targets.html#the-harness-field),
        /// Path to the Cargo.toml of the rust compiler workspace, for usage in rustc_private
        /// not that of `cargo fmt`. The file contents will be passed on the
        /// generated or otherwise managed by a build system outside of Cargo,
        /// though Cargo might be the eventual consumer.
    /// Projects that have a Cargo.toml or a rust-project.json in a
    pub cargo_toml_not_found: bool,
    /// Custom command to be executed instead of `cargo` for runnables.
    pub override_cargo: Option<String>,
    /// Additional arguments for the `cargo`, e.g. `--release`.
    pub cargo_extra_args: Vec<String>,
        self.cargo_extraArgs(source_root)
        self.cargo_extraEnv(source_root)
        let mut extra_env = self.cargo_extraEnv(source_root).clone();
            cargo_toml_not_found: self.notifications_cargoTomlNotFound().to_owned(),
    pub fn cargo_autoreload_config(&self, source_root: Option<SourceRootId>) -> bool {
        self.cargo_autoreload(source_root).to_owned()
        self.cargo_buildScripts_enable(source_root).to_owned() || self.procMacro_enable().to_owned()
    pub fn cargo(&self, source_root: Option<SourceRootId>) -> CargoConfig {
        let sysroot = self.cargo_sysroot(source_root).as_ref().map(|sysroot| {
            self.cargo_sysrootSrc(source_root).as_ref().map(|sysroot| self.root_path.join(sysroot));
        CargoConfig {
            all_targets: *self.cargo_allTargets(source_root),
            features: match &self.cargo_features(source_root) {
                CargoFeaturesDef::All => CargoFeatures::All,
                CargoFeaturesDef::Selected(features) => CargoFeatures::Selected {
                    no_default_features: self.cargo_noDefaultFeatures(source_root).to_owned(),
            target: self.cargo_target(source_root).clone(),
                        self.cargo_cfgs(source_root).iter().partition_map(|s| {
            wrap_rustc_in_build_scripts: *self.cargo_buildScripts_useRustcWrapper(source_root),
            invocation_strategy: match self.cargo_buildScripts_invocationStrategy(source_root) {
            run_build_script_command: self.cargo_buildScripts_overrideCommand(source_root).clone(),
            extra_args: self.cargo_extraArgs(source_root).clone(),
            extra_env: self.cargo_extraEnv(source_root).clone(),
            no_deps: *self.cargo_noDeps(source_root),
    pub(crate) fn cargo_test_options(&self, source_root: Option<SourceRootId>) -> CargoOptions {
        CargoOptions {
            target_tuples: self.cargo_target(source_root).clone().into_iter().collect(),
            no_default_features: *self.cargo_noDefaultFeatures(source_root),
            all_features: matches!(self.cargo_features(source_root), CargoFeaturesDef::All),
            features: match self.cargo_features(source_root).clone() {
                CargoFeaturesDef::All => vec![],
                CargoFeaturesDef::Selected(it) => it,
            Some(_) | None => FlycheckConfig::CargoCommand {
                options: CargoOptions {
                            self.cargo_target(source_root).clone().into_iter().collect()
                        .unwrap_or(*self.cargo_allTargets(source_root)),
                        .unwrap_or(*self.cargo_noDefaultFeatures(source_root)),
                            .unwrap_or(self.cargo_features(source_root)),
                        CargoFeaturesDef::All
                        .unwrap_or_else(|| self.cargo_features(source_root).clone())
                        CargoFeaturesDef::All => vec![],
                        CargoFeaturesDef::Selected(it) => it,
        self.cargo_targetDir(source_root).as_ref().and_then(|target_dir| match target_dir {
                let env_var = env::var("CARGO_TARGET_DIR").ok();
        *self.cargo_buildScripts_rebuildOnSave(source_root)
            override_cargo: self.runnables_command(source_root).clone(),
            cargo_extra_args: self.runnables_extraArgs(source_root).clone(),
enum CargoFeaturesDef {
        "CargoFeaturesDef" => set! {
                        "Pass `--all-features` to cargo",
        "Option<CargoFeaturesDef>" => set! {
                        "Pass `--all-features` to cargo",
    fn cargo_target_dir_unset() {
        assert_eq!(config.cargo_targetDir(None), &None);
            matches!(config.flycheck(None), FlycheckConfig::CargoCommand { options, .. } if options.target_dir.is_none())
    fn cargo_target_dir_subdir() {
        assert_eq!(config.cargo_targetDir(None), &Some(TargetDirectory::UseSubdirectory(true)));
            Utf8PathBuf::from(std::env::var("CARGO_TARGET_DIR").unwrap_or("target".to_owned()));
            matches!(config.flycheck(None), FlycheckConfig::CargoCommand { options, .. } if options.target_dir == Some(target.join("rust-analyzer")))
    fn cargo_target_dir_relative_dir() {
            config.cargo_targetDir(None),
            matches!(config.flycheck(None), FlycheckConfig::CargoCommand { options, .. } if options.target_dir == Some(Utf8PathBuf::from("other_folder")))
./vendor/rust-analyzer/crates/rust-analyzer/src/config.rs
        cargo.loadOutDirsFromCheck -> cargo.buildScripts.enable;
        cargo.runBuildScripts -> cargo.buildScripts.enable;
        cargo.runBuildScriptsCommand -> cargo.buildScripts.overrideCommand;
        cargo.useRustcWrapperForBuildScripts -> cargo.buildScripts.useRustcWrapper;
        runnables.cargoExtraArgs -> runnables.extraArgs ;
        runnables.overrideCargo -> runnables.command ;
    // cargo_allFeatures, cargo_features -> cargo_features
    if let Some(Value::Bool(true)) = copy.pointer("/cargo/allFeatures") {
        merge(json, json!({ "cargo": { "features": "all" } }));
./vendor/rust-analyzer/crates/rust-analyzer/src/config/patch_old_style.rs
use cargo_metadata::PackageId;
./vendor/rust-analyzer/crates/rust-analyzer/src/diagnostics.rs
//! `cargo check` json format to the LSP diagnostic format.
./vendor/rust-analyzer/crates/rust-analyzer/src/diagnostics/to_proto.rs
use crate::command::{CargoParser, CommandHandle};
/// This is analogous to discovering a cargo project + running `cargo-metadata` on it, but for non-Cargo build systems.
impl CargoParser<DiscoverProjectMessage> for DiscoverProjectParser {
./vendor/rust-analyzer/crates/rust-analyzer/src/discover.rs
//! Flycheck provides the functionality needed to run `cargo check` to provide
use cargo_metadata::PackageId;
pub(crate) use cargo_metadata::diagnostic::{
use crate::command::{CargoParser, CommandHandle};
pub(crate) struct CargoOptions {
impl CargoOptions {
                // No --benches unfortunately, as this implies --tests (see https://github.com/rust-lang/cargo/issues/6454),
    CargoCommand {
        options: CargoOptions,
            FlycheckConfig::CargoCommand { .. } => false,
            FlycheckConfig::CargoCommand { command, .. } => write!(f, "cargo {command}"),
/// running `cargo check` (or other compatible command) and providing
    /// Schedule a re-start of the cargo check worker to do a workspace wide check.
    /// Schedule a re-start of the cargo check worker to do a package wide check.
    /// Stop this cargo check worker.
    /// CargoHandle exists to wrap around the communication needed to be able to
    /// run `cargo check` without blocking. Currently the Rust standard library
    command_handle: Option<CommandHandle<CargoCheckMessage>>,
    command_receiver: Option<Receiver<CargoCheckMessage>>,
    CheckEvent(Option<CargoCheckMessage>),
                    match CommandHandle::spawn(command, CargoCheckParser, sender) {
                    CargoCheckMessage::CompilerArtifact(msg) => {
                    CargoCheckMessage::Diagnostic { diagnostic, package_id } => {
            FlycheckConfig::CargoCommand { command, options, ansi_color_output } => {
                    toolchain::command(Tool::Cargo.path(), &*self.root, &options.extra_env);
enum CargoCheckMessage {
    CompilerArtifact(cargo_metadata::Artifact),
struct CargoCheckParser;
impl CargoParser<CargoCheckMessage> for CargoCheckParser {
    fn from_line(&self, line: &str, error: &mut String) -> Option<CargoCheckMessage> {
                JsonMessage::Cargo(message) => match message {
                    cargo_metadata::Message::CompilerArtifact(artifact) if !artifact.fresh => {
                        Some(CargoCheckMessage::CompilerArtifact(artifact))
                    cargo_metadata::Message::CompilerMessage(msg) => {
                        Some(CargoCheckMessage::Diagnostic {
                    Some(CargoCheckMessage::Diagnostic { diagnostic: message, package_id: None })
    fn from_eof(&self) -> Option<CargoCheckMessage> {
    Cargo(cargo_metadata::Message),
./vendor/rust-analyzer/crates/rust-analyzer/src/flycheck.rs
use load_cargo::SourceRootConfig;
    target_spec::{CargoTargetSpec, ProjectJsonTargetSpec, TargetSpec},
    test_runner::{CargoTestHandle, CargoTestMessage},
    pub(crate) test_run_session: Option<Vec<CargoTestHandle>>,
    pub(crate) test_run_sender: Sender<CargoTestMessage>,
    pub(crate) test_run_receiver: Receiver<CargoTestMessage>,
    /// *First*, we run `cargo metadata`, which gives us fast results for
    /// *Second*, we run `cargo check` which runs build scripts and compiles
    /// `cargo check`, the user edits `Cargo.toml`, we notice this, and the new
    /// `cargo metadata` completes before `cargo check`.
    /// the user just adds comments or whitespace to Cargo.toml, we do not want
                // do I resolve a "workspace_root" to its corresponding id without having to rely on a cargo.toml's ( or project json etc.) file id?
                ProjectWorkspaceKind::Cargo { cargo, .. }
                | ProjectWorkspaceKind::DetachedFile { cargo: Some((cargo, _, _)), .. } => {
                    let Some(target_idx) = cargo.target_by_root(path) else {
                    let target_data = &cargo[target_idx];
                    let package_data = &cargo[target_data.package];
                    return Some(TargetSpec::Cargo(CargoTargetSpec {
                        workspace_root: cargo.workspace_root().to_path_buf(),
                        cargo_toml: package_data.manifest.clone(),
                        package: cargo.package_flag(package_data),
./vendor/rust-analyzer/crates/rust-analyzer/src/global_state.rs
                    TargetSpec::Cargo(c) => (c.target, c.workspace_root, c.package),
                        project_model::ProjectWorkspaceKind::Cargo { cargo, .. }
                            cargo: Some((cargo, _, _)),
                        } => *cargo.workspace_root() == root,
                    project_model::ProjectWorkspaceKind::Cargo { cargo, .. }
                        cargo: Some((cargo, _, _)),
                    } => cargo.packages().any(|pkg| {
                        cargo[pkg]
                            .any(|&it| crate_root_paths.contains(&cargo[it].root.as_path()))
./vendor/rust-analyzer/crates/rust-analyzer/src/handlers/notification.rs
use project_model::{CargoWorkspace, ManifestPath, ProjectWorkspaceKind, TargetKind};
    target_spec::{CargoTargetSpec, TargetSpec},
    test_runner::{CargoTestHandle, TestTarget},
// cargo test requires:
//   underscores. cargo test requires the real name.
fn all_test_targets(cargo: &CargoWorkspace) -> impl Iterator<Item = TestTarget> {
    cargo.packages().filter(|p| cargo[*p].is_member).flat_map(|p| {
        let package = &cargo[p];
            let target = &cargo[*t];
fn find_test_target(namespace_root: &str, cargo: &CargoWorkspace) -> Option<TestTarget> {
    all_test_targets(cargo).find(|t| namespace_root == t.target.replace('-', "_"))
        if let ProjectWorkspaceKind::Cargo { cargo, .. } = &ws.kind {
                        if let Some(target) = find_test_target(&root, cargo) {
                None => all_test_targets(cargo).map(|target| (target, None)).collect(),
                let handle = CargoTestHandle::new(
                    state.config.cargo_test_options(None),
                    cargo.workspace_root(),
        if file_path.file_name().unwrap_or_default() == "Cargo.toml" {
                    ProjectWorkspaceKind::Cargo { cargo, .. }
                    | ProjectWorkspaceKind::DetachedFile { cargo: Some((cargo, _, _)), .. } => {
                        cargo.parent_manifests(&manifest_path)
        let cargo_spec = match TargetSpec::for_file(&snap, file_id)? {
            Some(TargetSpec::Cargo(it)) => it,
            let cargo_toml_url = to_proto::url_from_abs_path(&cargo_spec.cargo_toml);
                target_uri: cargo_toml_url,
            if let lsp_ext::RunnableArgs::Cargo(r) = &mut runnable.args
                && let Some(TargetSpec::Cargo(CargoTargetSpec {
    // Add `cargo check` and `cargo test` for all targets of the whole package
        Some(TargetSpec::Cargo(spec)) => {
                    spec.cargo_toml.parent().to_path_buf()
                let mut cargo_args =
                    cargo_args.push("--all-targets".to_owned());
                cargo_args.extend(config.cargo_extra_args.iter().cloned());
                        "cargo {cmd} -p {}{all_targets}",
                    kind: lsp_ext::RunnableKind::Cargo,
                    args: lsp_ext::RunnableArgs::Cargo(lsp_ext::CargoRunnableArgs {
                        override_cargo: config.override_cargo.clone(),
                        cargo_args,
                let mut cargo_args = vec!["check".to_owned(), "--workspace".to_owned()];
                cargo_args.extend(config.cargo_extra_args.iter().cloned());
                    label: "cargo check --workspace".to_owned(),
                    kind: lsp_ext::RunnableKind::Cargo,
                    args: lsp_ext::RunnableArgs::Cargo(lsp_ext::CargoRunnableArgs {
                        override_cargo: config.override_cargo,
                        cargo_args,
    // Fixes from `cargo check`.
        ProjectWorkspaceKind::Cargo { cargo, .. }
        | ProjectWorkspaceKind::DetachedFile { cargo: Some((cargo, _, _)), .. } => {
            Some((cargo, &ws.sysroot))
    let (cargo, sysroot) = match ws_and_sysroot {
    let target_dir = cargo.map(|cargo| cargo.target_directory()).map(|p| p.as_str());
pub(crate) fn handle_open_cargo_toml(
    params: lsp_ext::OpenCargoTomlParams,
    let _p = tracing::info_span!("handle_open_cargo_toml").entered();
    let cargo_spec = match TargetSpec::for_file(&snap, file_id)? {
        Some(TargetSpec::Cargo(it)) => it,
    let cargo_toml_url = to_proto::url_from_abs_path(&cargo_spec.cargo_toml);
        Location::new(cargo_toml_url, Range::default()).into();
fn should_skip_target(runnable: &Runnable, cargo_spec: Option<&TargetSpec>) -> bool {
            match &cargo_spec {
                Some(TargetSpec::Cargo(_)) => {
        let cargo_toml_path = path.join("../Cargo.toml")?;
        if fs::metadata(cargo_toml_path.as_path()?).is_ok() {
            let crate_path = cargo_toml_path.parent()?;
./vendor/rust-analyzer/crates/rust-analyzer/src/handlers/request.rs
//! Fully integrated benchmarks for rust-analyzer, which load real cargo
use project_model::CargoConfig;
use load_cargo::{LoadCargoConfig, ProcMacroServerChoice, load_workspace_at};
    let cargo_config = CargoConfig {
        ..CargoConfig::default()
    let load_cargo_config = LoadCargoConfig {
            &cargo_config,
            &load_cargo_config,
            "self.data.cargo_buildScripts_rebuildOnSave",
            "self. data. cargo_buildScripts_rebuildOnSave",
    let cargo_config = CargoConfig {
        ..CargoConfig::default()
    let load_cargo_config = LoadCargoConfig {
            &cargo_config,
            &load_cargo_config,
    let cargo_config = CargoConfig {
        ..CargoConfig::default()
    let load_cargo_config = LoadCargoConfig {
            &cargo_config,
            &load_cargo_config,
./vendor/rust-analyzer/crates/rust-analyzer/src/integrated_benchmarks.rs
            "openCargoToml": true,
                "kinds": [ "cargo" ],
./vendor/rust-analyzer/crates/rust-analyzer/src/lsp/capabilities.rs
    Cargo(CargoRunnableArgs),
    Cargo,
pub struct CargoRunnableArgs {
    /// Command to be executed instead of cargo
    pub override_cargo: Option<String>,
    pub cargo_args: Vec<String>,
pub enum OpenCargoToml {}
impl Request for OpenCargoToml {
    type Params = OpenCargoTomlParams;
    const METHOD: &'static str = "experimental/openCargoToml";
pub struct OpenCargoTomlParams {
./vendor/rust-analyzer/crates/rust-analyzer/src/lsp/ext.rs
    target_spec::{CargoTargetSpec, TargetSpec},
        Some(TargetSpec::Cargo(spec)) => {
            let (cargo_args, executable_args) = CargoTargetSpec::runnable_args(
                _ => spec.cargo_toml.parent().to_owned(),
                kind: lsp_ext::RunnableKind::Cargo,
                args: lsp_ext::RunnableArgs::Cargo(lsp_ext::CargoRunnableArgs {
                    override_cargo: config.override_cargo,
                    cargo_args,
            let (cargo_args, executable_args) =
                CargoTargetSpec::runnable_args(snap, None, &runnable.kind, &runnable.cfg);
                kind: lsp_ext::RunnableKind::Cargo,
                args: lsp_ext::RunnableArgs::Cargo(lsp_ext::CargoRunnableArgs {
                    override_cargo: config.override_cargo,
                    cargo_args,
                    lsp_ext::RunnableArgs::Cargo(c) => c.workspace_root.is_some(),
    let lsp_ext::RunnableArgs::Cargo(r) = &mut runnable.args else {
        r.cargo_args.insert(0, "insta".to_owned());
./vendor/rust-analyzer/crates/rust-analyzer/src/lsp/to_proto.rs
    /// It's unclear if making from source `cargo xtask install` builds more
./vendor/rust-analyzer/crates/rust-analyzer/src/lsp/utils.rs
    test_runner::{CargoTestMessage, CargoTestOutput, TestState},
    TestResult(CargoTestMessage),
                pattern: Some("**/Cargo.toml".into()),
                pattern: Some("**/Cargo.lock".into()),
                self.handle_cargo_test_msg(message);
                    self.handle_cargo_test_msg(message);
        if (self.config.cargo_autoreload_config(None)
    fn handle_cargo_test_msg(&mut self, message: CargoTestMessage) {
            CargoTestOutput::Test { name, state } => {
            CargoTestOutput::Suite => (),
            CargoTestOutput::Finished => {
            CargoTestOutput::Custom { text } => {
                                "flycheck {id}: File with cargo diagnostic not found in VFS: {}",
                            Some(format!("cargo check failed to start: {err}"));
                            result.err().map(|err| format!("cargo check failed to start: {err}"));
            .on::<NO_RETRY, lsp_ext::OpenCargoToml>(handlers::handle_open_cargo_toml)
./vendor/rust-analyzer/crates/rust-analyzer/src/main_loop.rs
//! mutable state. For example, when the user edits `Cargo.toml` by adding a new
//! not instantaneous -- it takes time to run `cargo metadata` and (for proc
//! macros) `cargo check`.
use load_cargo::{ProjectFolders, load_proc_macro};
        if self.config.cargo(None) != old_config.cargo(None) {
            self.fetch_workspaces_queue.request_op("cargo config changed".to_owned(), req)
        if !self.config.cargo_autoreload_config(None)
            message.push_str("Consider adding the `Cargo.toml` of the workspace to the [`linkedProjects`](https://rust-analyzer.github.io/book/configuration.html#linkedProjects) setting.\n\n");
                if let ProjectWorkspaceKind::Cargo { error: Some(error), .. }
                    cargo: Some((_, _, Some(error))), ..
                        "Failed to read Cargo metadata with dependencies for `{}`: {:#}\n\n",
                if let ProjectWorkspaceKind::Cargo { rustc: Err(Some(err)), .. } = &ws.kind {
            let cargo_config = self.config.cargo(None);
                                &cargo_config,
                                &cargo_config,
                        &cargo_config,
        let config = self.config.cargo(None);
            // Here, we completely changed the workspace (Cargo.toml edit), so
                                    (base.clone(), "**/Cargo.{lock,toml}"),
                                    format!("{base}/**/Cargo.{{toml,lock}}"),
                    ProjectWorkspaceKind::Cargo { cargo, .. }
                    | ProjectWorkspaceKind::DetachedFile { cargo: Some((cargo, ..)), .. } => cargo
            FlycheckConfig::CargoCommand { .. } => {
                                ProjectWorkspaceKind::Cargo { cargo, .. }
                                    cargo: Some((cargo, _, _)),
                                } => (cargo.workspace_root(), Some(cargo.manifest_path())),
// FIXME: Move this into load-cargo?
    if let "Cargo.toml" | "Cargo.lock" = file_name {
    // .cargo/config{.toml}
        let is_cargo_config = matches!(file_name, "config.toml" | "config")
            && path.parent().map(|parent| parent.as_str().ends_with(".cargo")).unwrap_or(false);
        return is_cargo_config;
./vendor/rust-analyzer/crates/rust-analyzer/src/reload.rs
use project_model::{CargoFeatures, ManifestPath, TargetKind};
    Cargo(CargoTargetSpec),
            TargetSpec::Cargo(cargo) => cargo.target_kind,
/// Abstract representation of Cargo target.
/// We use it to cook up the set of cli args we need to pass to Cargo to
pub(crate) struct CargoTargetSpec {
    pub(crate) cargo_toml: ManifestPath,
impl CargoTargetSpec {
        spec: Option<CargoTargetSpec>,
        let mut cargo_args = Vec::new();
                cargo_args.push("test".to_owned());
                cargo_args.push("test".to_owned());
                cargo_args.push("bench".to_owned());
                cargo_args.push("test".to_owned());
                cargo_args.push("--doc".to_owned());
                    Some(CargoTargetSpec { target_kind: TargetKind::Test, .. }) => "test",
                cargo_args.push(subcommand.to_owned());
            spec.push_to(&mut cargo_args, kind);
        let cargo_config = snap.config.cargo(None);
        match &cargo_config.features {
            CargoFeatures::All => {
                cargo_args.push("--all-features".to_owned());
                    cargo_args.push("--features".to_owned());
                    cargo_args.push(feature);
            CargoFeatures::Selected { features, no_default_features } => {
                    cargo_args.push("--features".to_owned());
                    cargo_args.push(feature);
                    cargo_args.push("--no-default-features".to_owned());
        cargo_args.extend(config.cargo_extra_args.iter().cloned());
        (cargo_args, executable_args)
./vendor/rust-analyzer/crates/rust-analyzer/src/target_spec.rs
//! This module provides the functionality needed to run `cargo test` in a background
    command::{CargoParser, CommandHandle},
    flycheck::CargoOptions,
        // the stdout field is not always present depending on cargo test flags
pub(crate) struct CargoTestMessage {
    pub output: CargoTestOutput,
pub(crate) enum CargoTestOutput {
pub(crate) struct CargoTestOutputParser {
impl CargoTestOutputParser {
impl CargoParser<CargoTestMessage> for CargoTestOutputParser {
    fn from_line(&self, line: &str, _error: &mut String) -> Option<CargoTestMessage> {
        Some(CargoTestMessage {
            output: if let Ok(message) = CargoTestOutput::deserialize(&mut deserializer) {
                CargoTestOutput::Custom { text: line.to_owned() }
    fn from_eof(&self) -> Option<CargoTestMessage> {
        Some(CargoTestMessage { target: self.target.clone(), output: CargoTestOutput::Finished })
pub(crate) struct CargoTestHandle {
    _handle: CommandHandle<CargoTestMessage>,
// Example of a cargo test command:
// cargo test --package my-package --bin my_bin --no-fail-fast -- module::func -Z unstable-options --format=json
impl CargoTestHandle {
        options: CargoOptions,
        sender: Sender<CargoTestMessage>,
        let mut cmd = toolchain::command(Tool::Cargo.path(), root, &options.extra_env);
        } else if let Some(cargo_target) = test_target.kind.as_cargo_target() {
            cmd.arg(format!("--{cargo_target}"));
            tracing::warn!("Running test for unknown cargo target {:?}", test_target.kind);
        cmd.arg(root.join("Cargo.toml"));
            _handle: CommandHandle::spawn(cmd, CargoTestOutputParser::new(&test_target), sender)?,
./vendor/rust-analyzer/crates/rust-analyzer/src/test_runner.rs
/// Cargo's version.
/// Returns information about cargo's version.
./vendor/rust-analyzer/crates/rust-analyzer/src/version.rs
//- /Cargo.toml
        {"id":31,"type":"vertex","label":"packageInformation","name":"foo","manager":"cargo","version":"0.0.0"}
./vendor/rust-analyzer/crates/rust-analyzer/tests/slow-tests/cli.rs
//! This tests run a full LSP event loop, spawn cargo and process stdlib from
//- /Cargo.toml
        "cargo": { "sysroot": "discover" },
//- /Cargo.toml
fn completes_items_from_standard_library_in_cargo_script() {
//- /dependency/Cargo.toml
//- /dependency2/Cargo.toml
#!/usr/bin/env -S cargo +nightly -Zscript
        "cargo": { "sysroot": null },
        r#"#!/usr/bin/env -S cargo +nightly -Zscript
//- /foo/Cargo.toml
//- /bar/Cargo.toml
              "cargoArgs": ["test", "--package", "foo", "--test", "spam"],
              "overrideCargo": null,
            "kind": "cargo",
              "overrideCargo": null,
              "cargoArgs": [
            "kind": "cargo",
              "cargoArgs": ["check", "--package", "foo", "--all-targets"],
              "overrideCargo": null,
            "kind": "cargo",
            "label": "cargo check -p foo --all-targets"
              "cargoArgs": ["test", "--package", "foo", "--all-targets"],
              "overrideCargo": null,
            "kind": "cargo",
            "label": "cargo test -p foo --all-targets"
//- /consumer/Cargo.toml
//- /dependency/Cargo.toml
//- /devdependency/Cargo.toml
                    "label": "cargo test -p [..] --all-targets",
                    "kind": "cargo",
                        "overrideCargo": null,
                        "cargoArgs": [
//- /foo/Cargo.toml
//- /foo/mainpkg/Cargo.toml
//- /foo/otherpkg/Cargo.toml
                "label": "cargo test -p mainpkg --all-targets",
                "kind": "cargo",
                    "overrideCargo": null,
                    "cargoArgs": [
                "label": "cargo test -p otherpkg --all-targets",
                "kind": "cargo",
                    "overrideCargo": null,
                    "cargoArgs": [
//- /Cargo.toml
//- /Cargo.toml
//- /Cargo.toml
//- /Cargo.toml
//- /Cargo.toml
//- /Cargo.toml
        "cargo": { "sysroot": "discover" },
//- /Cargo.toml
//- /Cargo.toml
    println!("cargo:rustc-cfg=atom_cfg");
    println!("cargo:rustc-cfg=featlike=\"set\"");
    println!("cargo:rerun-if-changed=build.rs");
            "cargo": {
//- /foo/Cargo.toml
//- /bar/Cargo.toml
        "cargo": {
//- /Cargo.toml
//- /foo/Cargo.toml
//- /bar/Cargo.toml
//- /foo/Cargo.toml
//- /bar/Cargo.toml
//- /baz/Cargo.toml
./vendor/rust-analyzer/crates/rust-analyzer/tests/slow-tests/main.rs
//- /p1/Cargo.toml
// //- /p1/Cargo.toml
// //- /p1/Cargo.toml
//- /p1/Cargo.toml
//- /p1/Cargo.toml
//- /p1/Cargo.toml
//- /p1/Cargo.toml
//- /p1/Cargo.toml
//- /p1/p2/Cargo.toml
//- /p1/Cargo.toml
//- /p1/p2/Cargo.toml
//- /p1/Cargo.toml
//- /p1/p2/Cargo.toml
//- /p1/Cargo.toml
//- /p1/p2/Cargo.toml
//- /p1/Cargo.toml
//- /p1/p2/Cargo.toml
//- /p1/Cargo.toml
//- /p1/p2/Cargo.toml
        //- /p1/Cargo.toml
// //- /p1/Cargo.toml
// //- /p2/Cargo.toml
// # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
//- /p1/Cargo.toml
//- /p1/Cargo.toml
//- /p1/Cargo.toml
./vendor/rust-analyzer/crates/rust-analyzer/tests/slow-tests/ratoml.rs
                "cargo": {
// Comparison functionality borrowed from cargo:
./vendor/rust-analyzer/crates/rust-analyzer/tests/slow-tests/support.rs
        // * Cargo may emit different PackageId depending on the working directory
./vendor/rust-analyzer/crates/rust-analyzer/tests/slow-tests/testdir.rs
//! # Cargo features
./vendor/rust-analyzer/crates/stdx/src/anymap.rs
Uncomment `default = [ "backtrace" ]` in `crates/stdx/Cargo.toml`.
./vendor/rust-analyzer/crates/stdx/src/lib.rs
//! <https://github.com/rust-lang/cargo/blob/905af549966f23a9288e9993a85d1249a5436556/crates/cargo-util/src/read2.rs>
//! <https://github.com/rust-lang/cargo/blob/58a961314437258065e23cb6316dfc121d96fb71/crates/cargo-util/src/process_builder.rs#L231>
./vendor/rust-analyzer/crates/stdx/src/process.rs
//! Generated by `cargo xtask codegen grammar`, do not edit by hand.
./vendor/rust-analyzer/crates/syntax/src/ast/generated/nodes.rs
//! Generated by `cargo xtask codegen grammar`, do not edit by hand.
./vendor/rust-analyzer/crates/syntax/src/ast/generated/tokens.rs
    match std::env::var("CARGO_TARGET_DIR") {
    let dir = env!("CARGO_MANIFEST_DIR");
        eprintln!("    NOTE: run `cargo test` locally and commit the updated files\n");
./vendor/rust-analyzer/crates/test-utils/src/lib.rs
//! Discovery of `cargo` & `rustc` executables.
    Cargo,
        cargo_proxy(self.name())
    /// 1) `$CARGO_HOME/bin/<executable_name>`
    ///    where $CARGO_HOME defaults to ~/.cargo (see <https://doc.rust-lang.org/cargo/guide/cargo-home.html>)
    ///    example: for cargo, this tries $CARGO_HOME/bin/cargo, or ~/.cargo/bin/cargo if $CARGO_HOME is unset.
    ///    It seems that this is a reasonable place to try for cargo, rustc, and rustup
    ///    example: for cargo, this checks $CARGO environment variable; for rustc, $RUSTC; etc
    ///    example: for cargo, this tries all paths in $PATH with appended `cargo`, returning the
        invoke(&[cargo_proxy, lookup_as_env_var, lookup_in_path], self.name())
    ///    example: for cargo, this checks $CARGO environment variable; for rustc, $RUSTC; etc
    ///    example: for cargo, this tries all paths in $PATH with appended `cargo`, returning the
    /// 3) `$CARGO_HOME/bin/<executable_name>`
    ///    where $CARGO_HOME defaults to ~/.cargo (see <https://doc.rust-lang.org/cargo/guide/cargo-home.html>)
    ///    example: for cargo, this tries $CARGO_HOME/bin/cargo, or ~/.cargo/bin/cargo if $CARGO_HOME is unset.
    ///    It seems that this is a reasonable place to try for cargo, rustc, and rustup
        invoke(&[lookup_as_env_var, lookup_in_path, cargo_proxy], self.name())
            Tool::Cargo => "cargo",
/// Looks up the binary in the cargo home directory if it exists.
fn cargo_proxy(executable_name: &str) -> Option<Utf8PathBuf> {
    let mut path = get_cargo_home()?;
fn get_cargo_home() -> Option<Utf8PathBuf> {
    if let Some(path) = env::var_os("CARGO_HOME") {
        path.push(".cargo");
./vendor/rust-analyzer/crates/toolchain/src/lib.rs
//! in `~/.cargo`, and for generated code in `./target/debug/build`. It will
./vendor/rust-analyzer/crates/vfs/src/lib.rs
    pub fn local_cargo_package(base: AbsPathBuf) -> Entry {
    pub fn cargo_package_dependency(base: AbsPathBuf) -> Entry {
./vendor/rust-analyzer/crates/vfs/src/loader.rs
//! cargo run --example minimal_lsp
./vendor/rust-analyzer/lib/lsp-server/examples/minimal_lsp.rs
    let preamble = format!("//! Generated by `cargo xtask codegen {cg}`, do not edit by hand.\n\n");
                    "\n    NOTE: run `cargo xtask codegen {cg}` locally and commit the updated files\n"
./vendor/rust-analyzer/xtask/src/codegen.rs
        // git repo. Instead, `cargo xtask release` runs this test before making
./vendor/rust-analyzer/xtask/src/codegen/assists_doc_tests.rs
    // need submodules for Cargo to parse the workspace correctly
    let cargo = std::env::var("CARGO").unwrap_or_else(|_| "cargo".to_owned());
        "{cargo} run --manifest-path {rust_repo}/src/tools/unstable-book-gen/Cargo.toml --
./vendor/rust-analyzer/xtask/src/codegen/lints.rs
    let _e = sh.push_env("CARGO_PROFILE_RELEASE_LTO", "thin");
    // let _e = sh.push_env("CARGO_PROFILE_RELEASE_DEBUG", "1");
        "cargo {command} --manifest-path ./crates/rust-analyzer/Cargo.toml --bin rust-analyzer --target {target_name} {features...} --release"
./vendor/rust-analyzer/xtask/src/dist.rs
            /// Use cargo-zigbuild
// Run `env UPDATE_XFLAGS=1 cargo build` to regenerate.
./vendor/rust-analyzer/xtask/src/flags.rs
        "cargo install --path crates/rust-analyzer --profile={profile} --locked --force --features force-always-assert {features...}"
            "cargo build --manifest-path ./crates/rust-analyzer/Cargo.toml --bin rust-analyzer --profile={profile} --locked --features force-always-assert {features...}"
        "cargo +nightly install --path crates/proc-macro-srv-cli --profile={profile} --locked --force --features sysroot-abi"
./vendor/rust-analyzer/xtask/src/install.rs
//! See <https://github.com/matklad/cargo-xtask/>.
//! expressible with just `cargo`. Notably, it provides tests via `cargo test -p xtask`
//! for code generation and `cargo xtask install` for installation of
//! This binary is integrated into the `cargo` command line by using an alias in
//! `.cargo/config`.
                cmd!(sh, "cargo build --release --features jemalloc").run()?;
        env::var("CARGO_MANIFEST_DIR").unwrap_or_else(|_| env!("CARGO_MANIFEST_DIR").to_owned());
    if cmd!(sh, "cargo fuzz --help").read().is_err() {
        cmd!(sh, "cargo install cargo-fuzz").run()?;
    cmd!(sh, "cargo fuzz run parser").run()?;
./vendor/rust-analyzer/xtask/src/main.rs
        cmd!(sh, "cargo fetch").run()?;
        cmd!(sh, "cargo build --release --package rust-analyzer --bin rust-analyzer").run()?;
./vendor/rust-analyzer/xtask/src/metrics.rs
        "cargo {command} --manifest-path ./crates/rust-analyzer/Cargo.toml --bin rust-analyzer --target {target_name} {features...} --release"
./vendor/rust-analyzer/xtask/src/pgo.rs
                check_cargo_toml(&path, text);
fn check_cargo_toml(path: &Path, text: String) {
                        "\ncargo internal dev-dependencies should not have a version.\n\
                        "\ncargo internal dependencies should have a version.\n\
    let meta = cmd!(sh, "cargo metadata --format-version 1").read().unwrap();
./vendor/rust-analyzer/xtask/src/tidy.rs
use ra_project_model::{CargoConfig, ProjectManifest, ProjectWorkspace, RustLibSource};
use ra_rust_analyzer::cli::load_cargo::{load_workspace, LoadCargoConfig, ProcMacroServerChoice};
    let mut cargo_config = CargoConfig::default();
    cargo_config.sysroot = Some(RustLibSource::Discover);
        &cargo_config,
    let load_cargo_config = LoadCargoConfig {
        load_workspace(workspace, &Default::default(), &load_cargo_config).unwrap();
    let mut cargo_config = CargoConfig::default();
    cargo_config.sysroot = Some(RustLibSource::Discover);
        &cargo_config,
    let load_cargo_config = LoadCargoConfig {
        load_workspace(workspace, &Default::default(), &load_cargo_config).unwrap();
./vendor/coccinelleforrust/src/parsing_rs/type_inference.rs
// See https://github.com/rust-lang/cargo/issues/5930
./vendor/ast-grep/crates/cli/src/bin/alias.rs
    let exit = open_in_editor(&PathBuf::from("Cargo.toml"), 1);
    let exit = open_in_editor(&PathBuf::from("Cargo.toml"), 1);
./vendor/ast-grep/crates/cli/src/print/interactive_print.rs
  Command::cargo_bin("ast-grep")?
./vendor/ast-grep/crates/cli/tests/help_test.rs
  Command::cargo_bin("ast-grep")?
  Command::cargo_bin("ast-grep")?
  Command::cargo_bin("ast-grep")?
  Command::cargo_bin("ast-grep")?
  Command::cargo_bin("ast-grep")?
  Command::cargo_bin("ast-grep")?
  Command::cargo_bin("ast-grep")?
  Command::cargo_bin("ast-grep")?
  Command::cargo_bin("ast-grep")?
  Command::cargo_bin("ast-grep")?
  Command::cargo_bin("ast-grep")?
./vendor/ast-grep/crates/cli/tests/run_test.rs
  Command::cargo_bin("ast-grep")?
  Command::cargo_bin("ast-grep")?
  Command::cargo_bin("ast-grep")?
  Command::cargo_bin("ast-grep")?
  Command::cargo_bin("ast-grep")?
  Command::cargo_bin("ast-grep")?
  Command::cargo_bin("ast-grep")?
  Command::cargo_bin("ast-grep")?
  Command::cargo_bin("ast-grep")?
  Command::cargo_bin("ast-grep")?
  Command::cargo_bin("ast-grep")?
  Command::cargo_bin("ast-grep")?
  Command::cargo_bin("ast-grep")?
  Command::cargo_bin("ast-grep")?
  Command::cargo_bin("ast-grep")?
  Command::cargo_bin("ast-grep")?
  Command::cargo_bin("ast-grep")?
  Command::cargo_bin("ast-grep")?
  Command::cargo_bin("ast-grep")?
./vendor/ast-grep/crates/cli/tests/scan_test.rs
  let message = "argument is missing. Example usage: \ncargo xtask 0.1.3\ncargo xtask schema";
  update_cargo_lock()?;
  let root_toml = Path::new("Cargo.toml");
fn update_cargo_lock() -> Result<()> {
  if Command::new("cargo").args(["build"]).status()?.success() {
    bail!("cargo build fail! cannot update Cargo.lock")
./vendor/ast-grep/xtask/src/main.rs
  // however, pwd is set to manifest dir, xtask in this case, during cargo test
  let xtask_path = std::env::var("CARGO_MANIFEST_DIR")?;
  let xtask_path = std::env::var("CARGO_MANIFEST_DIR")?;
./vendor/ast-grep/xtask/src/schema.rs
  // Base relative paths on the Cargo.toml location
    let absolute_path = Path::new(&env::var("CARGO_MANIFEST_DIR").unwrap())
./vendor/rust-embed/impl/src/lib.rs
#[folder = "$CARGO_MANIFEST_DIR/examples/public/"]
./vendor/rust-embed/tests/interpolated_path.rs
  let metadata = fs::metadata(format!("{}/examples/public/index.html", env!("CARGO_MANIFEST_DIR"))).unwrap();
  let metadata = fs::metadata(format!("{}/examples/public/index.html", env!("CARGO_MANIFEST_DIR"))).unwrap();
  let metadata = fs::metadata(format!("{}/examples/public/index.html", env!("CARGO_MANIFEST_DIR"))).unwrap();
./vendor/rust-embed/tests/metadata.rs
//! usage: cargo run --example jsonld-context <JSON-LD file> [context file]
./vendor/sophia_rs/sophia/examples/jsonld-context.rs
    ///   set `behavior_version` on the Config or enable the `behavior-version-latest` Cargo
./vendor/amazon-q-developer-cli/crates/amzn-codewhisperer-client/src/client.rs
    /// `behavior-version-latest` cargo feature. ```no_run
    /// `behavior-version-latest` cargo feature. ```no_run
    /// This is equivalent to enabling the `behavior-version-latest` Cargo feature
                                .with_behavior_version(config.behavior_version.expect("Invalid client configuration: A behavior major version must be set when sending a request or constructing a client. You must set it during client construction or by enabling the `behavior-version-latest` cargo feature."))
./vendor/amazon-q-developer-cli/crates/amzn-codewhisperer-client/src/config.rs
pub static PKG_VERSION: &str = env!("CARGO_PKG_VERSION");
./vendor/amazon-q-developer-cli/crates/amzn-codewhisperer-client/src/meta.rs
    ///   set `behavior_version` on the Config or enable the `behavior-version-latest` Cargo
./vendor/amazon-q-developer-cli/crates/amzn-codewhisperer-streaming-client/src/client.rs
    /// `behavior-version-latest` cargo feature. ```no_run
    /// `behavior-version-latest` cargo feature. ```no_run
    /// This is equivalent to enabling the `behavior-version-latest` Cargo feature
                                .with_behavior_version(config.behavior_version.expect("Invalid client configuration: A behavior major version must be set when sending a request or constructing a client. You must set it during client construction or by enabling the `behavior-version-latest` cargo feature."))
./vendor/amazon-q-developer-cli/crates/amzn-codewhisperer-streaming-client/src/config.rs
pub static PKG_VERSION: &str = env!("CARGO_PKG_VERSION");
./vendor/amazon-q-developer-cli/crates/amzn-codewhisperer-streaming-client/src/meta.rs
    ///   set `behavior_version` on the Config or enable the `behavior-version-latest` Cargo
./vendor/amazon-q-developer-cli/crates/amzn-consolas-client/src/client.rs
    /// `behavior-version-latest` cargo feature. ```no_run
    /// `behavior-version-latest` cargo feature. ```no_run
    /// This is equivalent to enabling the `behavior-version-latest` Cargo feature
                                .with_behavior_version(config.behavior_version.expect("Invalid client configuration: A behavior major version must be set when sending a request or constructing a client. You must set it during client construction or by enabling the `behavior-version-latest` cargo feature."))
./vendor/amazon-q-developer-cli/crates/amzn-consolas-client/src/config.rs
pub static PKG_VERSION: &str = env!("CARGO_PKG_VERSION");
./vendor/amazon-q-developer-cli/crates/amzn-consolas-client/src/meta.rs
    ///   set `behavior_version` on the Config or enable the `behavior-version-latest` Cargo
./vendor/amazon-q-developer-cli/crates/amzn-qdeveloper-streaming-client/src/client.rs
    /// `behavior-version-latest` cargo feature. ```no_run
    /// `behavior-version-latest` cargo feature. ```no_run
    /// This is equivalent to enabling the `behavior-version-latest` Cargo feature
                                .with_behavior_version(config.behavior_version.expect("Invalid client configuration: A behavior major version must be set when sending a request or constructing a client. You must set it during client construction or by enabling the `behavior-version-latest` cargo feature."))
./vendor/amazon-q-developer-cli/crates/amzn-qdeveloper-streaming-client/src/config.rs
pub static PKG_VERSION: &str = env!("CARGO_PKG_VERSION");
./vendor/amazon-q-developer-cli/crates/amzn-qdeveloper-streaming-client/src/meta.rs
    ///   set `behavior_version` on the Config or enable the `behavior-version-latest` Cargo
./vendor/amazon-q-developer-cli/crates/amzn-toolkit-telemetry-client/src/client.rs
    /// `behavior-version-latest` cargo feature.
    /// `behavior-version-latest` cargo feature.
    /// This is equivalent to enabling the `behavior-version-latest` Cargo feature
                                .with_behavior_version(behavior_version.expect("Invalid client configuration: A behavior major version must be set when sending a request or constructing a client. You must set it during client construction or by enabling the `behavior-version-latest` cargo feature."))
./vendor/amazon-q-developer-cli/crates/amzn-toolkit-telemetry-client/src/config.rs
pub static PKG_VERSION: &str = env!("CARGO_PKG_VERSION");
./vendor/amazon-q-developer-cli/crates/amzn-toolkit-telemetry-client/src/meta.rs
    println!("cargo:rerun-if-changed=def.json");
./vendor/amazon-q-developer-cli/crates/aws-toolkit-telemetry-definitions/build.rs
        env!("CARGO_PKG_VERSION")
    println!("cargo:rerun-if-changed=def.json");
./vendor/amazon-q-developer-cli/crates/chat-cli/build.rs
const VERSION_VALUE: &str = env!("CARGO_PKG_VERSION");
./vendor/amazon-q-developer-cli/crates/chat-cli/src/aws_common/user_agent_override_interceptor.rs
const USER_AGENT_VERSION_VALUE: &str = env!("CARGO_PKG_VERSION");
./vendor/amazon-q-developer-cli/crates/chat-cli/src/cli/chat/tools/use_aws.rs
        let current_version = env!("CARGO_PKG_VERSION");
./vendor/amazon-q-developer-cli/crates/chat-cli/src/cli/mod.rs
        let migration_folder = std::path::Path::new(env!("CARGO_MANIFEST_DIR")).join("src/database/sqlite_migrations");
./vendor/amazon-q-developer-cli/crates/chat-cli/src/database/mod.rs
        let output = std::process::Command::new("cargo")
            .expect("Failed to execute cargo metadata");
            serde_json::from_slice(&output.stdout).expect("Failed to parse cargo metadata");
        std::process::Command::new("cargo")
./vendor/amazon-q-developer-cli/crates/chat-cli/src/mcp_client/client.rs
            version: env!("CARGO_PKG_VERSION").to_owned(),
./vendor/amazon-q-developer-cli/crates/chat-cli/src/os/diagnostics.rs
    let version = env!("CARGO_PKG_VERSION");
./vendor/amazon-q-developer-cli/crates/chat-cli/src/request.rs
const PRODUCT_VERSION: &str = env!("CARGO_PKG_VERSION");
            .aws_product_version(env!("CARGO_PKG_VERSION"))
./vendor/amazon-q-developer-cli/crates/chat-cli/src/telemetry/mod.rs
        patterns.insert("cargo_operations".to_string(), 
            Regex::new(r"cargo\s+(run|build|test|clippy|fmt|install)").unwrap());
            if line.contains("```") || line.contains("cargo run") || line.contains("git commit") {
./vendor/amazon-q-developer-cli/crates/log-processor/src/lib.rs
            "impl", "struct", "fn", "cargo", "rust", "optimization", 
            ("cargo", "build_system"),
./vendor/amazon-q-developer-cli/crates/unified-knowledge/src/interactive_quiz.rs
        patterns.insert("cargo_operations".to_string(), 
            Regex::new(r"cargo\s+(run|build|test|clippy|fmt|install)").unwrap());
            if line.contains("```") || line.contains("cargo run") || line.contains("git commit") {
./vendor/amazon-q-developer-cli/src/log_processor.rs
                "cargo:warning=could not execute `llvm-config` one or more \
                "cargo:warning=could not execute `xcode-select` one or more \
./vendor/amazon-q-developer-cli/target/debug/build/clang-sys-f0d249b62f9aa798/out/common.rs
    println!("cargo:rustc-link-search={}", directory.display());
            println!("cargo:rustc-link-search={}", lib.display());
            println!("cargo:rustc-link-search=native={}", out);
        println!("cargo:rustc-link-lib=dylib=libclang");
        println!("cargo:rustc-link-lib=dylib={}", name);
./vendor/amazon-q-developer-cli/target/debug/build/clang-sys-f0d249b62f9aa798/out/dynamic.rs
//! To import `Google-Oauth` to your project, please add this line into your `Cargo.toml`.
//! You can build this library with ``wasm-pack build --features wasm``. (`cargo install wasm-pack` to install first.)
./vendor/google-oauth/src/lib.rs
//! cargo run --example chain_logging_example --features "logging cli"
./vendor/llm/examples/chain_logging_example.rs
//   cargo run --example unified_tool_calling_example -- [provider] [scenario]
            println!("Example: cargo run --example unified_tool_calling_example -- openai multi");
./vendor/llm/examples/unified_tool_calling_example.rs
    println!("cargo::rustc-check-cfg=cfg(no_diagnostic_namespace)");
./vendor/google-ai-rs/google-ai-rs/build.rs
    App::new(env!("CARGO_PKG_NAME"))
        .version(env!("CARGO_PKG_VERSION"))
        .author(env!("CARGO_PKG_AUTHORS"))
        .about(env!("CARGO_PKG_DESCRIPTION"))
./vendor/refren/src/main.rs
// Queries cargo to find the name of the current crate, then runs cargo clean to
// when we run cargo check. Hopefully eventually there'll be a nicer way to
// integrate with cargo such that we won't need to do this.
        let mut cmd = Command::new("cargo");
    let mut cmd = Command::new("cargo");
    let output = Command::new("cargo")
./vendor/em-refactor/em-refactor-cli/src/cmd_executer.rs
// Need to add compiler dependencies, as they are not listed in Cargo.toml
./vendor/em-refactor/em-refactor-cli/src/driver.rs
/// Wrapper binary which invokes cargo check with the RUSTC_WRAPPER env var set to the binary produced by driver.rs
/// This will cause cargo to invoke the driver.rs binary with the same arguments as if the driver.rs binary was rustc.
/// The driver.rs binary will instead be linked against librustc_driver, as cargo executes this binary
    // This might cause the local cargo index to be locked, so we cannot run multiple tests on the same project in parallell.
    // https://github.com/rust-lang/cargo/issues/7490
./vendor/em-refactor/em-refactor-cli/src/main.rs
        cargo_em_refactor()
        cargo_em_refactor()
        cargo_em_refactor()
        cargo_em_refactor()
        cargo_em_refactor()
        cargo_em_refactor()
        cargo_em_refactor()
        cargo_em_refactor()
        cargo_em_refactor()
        cargo_em_refactor()
        cargo_em_refactor()
        cargo_em_refactor()
    cargo-em-refactor [FLAGS] [OPTIONS] <SUBCOMMAND>"#));
        cargo_em_refactor()
        cargo_em_refactor()
        cargo_em_refactor()
        cargo_em_refactor()
        cargo_em_refactor()
./vendor/em-refactor/em-refactor-cli/tests/cli_tests.rs
pub fn cargo_em_refactor() -> Command {
    Command::cargo_bin("cargo-em-refactor").unwrap()
./vendor/em-refactor/em-refactor-cli/tests/cli_tests_utils/mod.rs
// run single threaded with: cargo test -- --test-threads=1
    Command::new("cargo")
    let mut assert = Command::cargo_bin("cargo-em-refactor")
./vendor/em-refactor/em-refactor-cli/tests/test_case/mod.rs
        .with_file_name("cargo-em-refactor");
./vendor/em-refactor/em-refactor-experiments/src/exp/experiments_runner.rs
        let out = Command::new("cargo")
./vendor/em-refactor/em-refactor-experiments/src/exp/experiments_runner_cmd.rs
// Need to add compiler dependencies, as they are not listed in Cargo.toml
./vendor/em-refactor/em-refactor-lib/src/lib.rs
    // Setting RUSTC_WRAPPER causes Cargo to pass 'rustc' as the first argument.
./vendor/em-refactor/em-refactor-lib/src/refactoring_invocation/arg_mappings.rs
    Path::new(env!("CARGO_MANIFEST_DIR"))
./vendor/ploke/crates/common/src/lib.rs
//! parsing the `Cargo.toml` file, and generating a `CrateContext` for each
    /// Failed to parse a `Cargo.toml` file.
    #[error("Failed to parse Cargo.toml at {path}: {source}")]
    /// The `package.name` field was missing from a `Cargo.toml` file.
    #[error("Missing 'package.name' in Cargo.toml at {path}")]
    /// The `package.version` field was missing from a `Cargo.toml` file.
    #[error("Missing 'package.version' in Cargo.toml at {path}")]
// Helper structs for deserializing Cargo.toml
/// Represents the `[package]` section of Cargo.toml.
/// Represents the overall structure of a parsed Cargo.toml manifest.
struct CargoManifest {
    /// The version string from Cargo.toml (e.g., "0.1.0").
    /// The absolute path to the crate's root directory (containing Cargo.toml).
    /// Parsed features from Cargo.toml.
    /// Parsed dependencies from Cargo.toml.
    /// Parsed dev-dependencies from Cargo.toml.
/// target crates, parses their `Cargo.toml` files, generates namespaces,
/// `Io` error reading `Cargo.toml`, `TomlParse` error, `SrcNotFound`).
        // --- 3.2.2 Implement Cargo.toml Parsing (Critical Errors) ---
        let cargo_toml_path = crate_root_path.join("Cargo.toml");
        let cargo_content = match fs::read_to_string(&cargo_toml_path) {
                // Critical error: Cannot proceed without Cargo.toml content.
                    path: cargo_toml_path.clone(),
        let manifest: CargoManifest = match toml::from_str(&cargo_content) {
                    path: cargo_toml_path.clone(),
            //     .filter(|(k, _)| k.starts_with("CARGO_"))
            //         .filter(|(k, _)| k.starts_with("CARGO_"))
///   critical files (Cargo.toml, src directory). These prevent any meaningful parsing.
                path: format!("Failed to parse Cargo.toml at {}", path.display()),
                    path: format!("Missing package.name in Cargo.toml at {}", path.display()),
                        "Missing package.version in Cargo.toml at {}",
./vendor/ploke/crates/ingest/syn_parser/src/discovery.rs
/// fixture directory or its `Cargo.toml` cannot be found). This is intended
./vendor/ploke/crates/ingest/syn_parser/src/lib.rs
    /// Returns a set of dependency names declared in the crate's Cargo.toml.
    /// Returns an iterator over the dependency names declared in the crate's Cargo.toml.
./vendor/ploke/crates/ingest/syn_parser/src/parser/graph/parsed_graph.rs
/// Active flags as seen by Cargo
    /// * enabled features defined in `Cargo.toml`,
./vendor/ploke/crates/ingest/syn_parser/src/parser/visitor/cfg_evaluator.rs
/// Active flags as seen by Cargo
./vendor/ploke/crates/ingest/syn_parser/tests/cfg_handling/parse_cfg_attempt.rs
    // Create Cargo.toml
    let cargo_content = r#"
    fs::write(crate_root.join("Cargo.toml"), cargo_content)?;
fn test_run_discovery_phase_missing_cargo_toml() -> Result<(), Box<dyn std::error::Error>> {
    fs::create_dir_all(&crate_root)?; // No Cargo.toml
        "Discovery should fail if Cargo.toml is missing"
    assert!(matches!(err, DiscoveryError::Io { ref path, .. } if path.ends_with("Cargo.toml")));
fn test_run_discovery_phase_invalid_cargo_toml() -> Result<(), Box<dyn std::error::Error>> {
    // Create invalid Cargo.toml
    fs::write(crate_root.join("Cargo.toml"), "this is not valid toml")?;
        "Discovery should fail for invalid Cargo.toml"
    // Create Cargo.toml but no src directory
    let cargo_content = r#"
    fs::write(crate_root.join("Cargo.toml"), cargo_content)?;
        crate1_root.join("Cargo.toml"),
        crate2_root.join("Cargo.toml"),
        crate3_root.join("Cargo.toml"),
        fixture_crate_root.join("Cargo.toml").exists(),
        "Fixture test crate Cargo.toml not found"
    assert_eq!(context.version, "0.1.0"); // Assuming this version in fixture Cargo.toml
./vendor/ploke/crates/ingest/syn_parser/tests/uuid_phase1_discovery/discovery_tests.rs
//!     RUST_LOG=log_test_node,log_test_import,test_id_regen=debug cargo test -p syn_parser -- --test-threads=1
//!     RUST_LOG=log_test_node,log_test_import,test_id_regen=debug cargo test -p syn_parser imports -- --test-threads=1
//!     RUST_LOG=log_test_node,log_test_import,test_id_regen=debug cargo test -p syn_parser imports::node_TupleStruct -- --test-threads=1
./vendor/ploke/crates/ingest/syn_parser/tests/uuid_phase2_partial_graphs/nodes/imports.rs
                // defined in the `Cargo.toml`? For now we are just going to use the directory name
./vendor/ploke/crates/ploke-tui/src/app_state.rs
// cargo workspace for linting.
// WARNING: If there are issues with tests targeting this fixture, add the this crate to the cargo
./vendor/ploke/tests/fixture_crates/fixture_attributes/src/lib.rs
// (associated_type_defaults) which caused issues with `cargo clippy` on stable.
./vendor/ploke/tests/fixture_crates/fixture_conflation/src/lib.rs
//! All code herein is valid, stable Rust that passes `cargo check`.
./vendor/ploke/tests/fixture_crates/fixture_spp_edge_cases/src/lib.rs
//! All code herein is valid, stable Rust that passes `cargo check`.
./vendor/ploke/tests/fixture_crates/fixture_spp_edge_cases_no_cfg/src/lib.rs
        let cargo_toml = crate_root.join("Cargo.toml");
        if !cargo_toml.exists() {
            let test_project = Path::new(env!("CARGO_MANIFEST_DIR")).join("tests/fixtures/simple/");
                Path::new(env!("CARGO_MANIFEST_DIR")).join("tests/fixtures/structs/");
            let test_project = Path::new(env!("CARGO_MANIFEST_DIR")).join("tests/fixtures/simple/");
                Path::new(env!("CARGO_MANIFEST_DIR")).join("tests/fixtures/structs/");
            let test_project = Path::new(env!("CARGO_MANIFEST_DIR")).join("tests/fixtures/inline/");
./vendor/extricrate/crates/extricrate/src/lib.rs
const CARGO_CLEAN: bool = true;
                    // run cargo clean
                    if CARGO_CLEAN {
                        let mut cmd = Command::new("cargo");
                            extraction.cargo_path.replace(&extraction.project_path, "")
                        debug!("cargo clean: {}, {}", out.status.success(), String::from_utf8_lossy(&out.stderr));
                    fix_lifetime_cargo_ms: Default::default(),
                    cargo_cycles: 0,
./vendor/rem/src/experiment/src/main.rs
    pub cargo_path: String,
        cargo_path: &str,
        let cargo_path = format!("{}/{}", project_path, cargo_path);
            cargo_path,
            self.cargo_path.as_str(),
                        "gix-pack/Cargo.toml",
                        "gix-mailmap/Cargo.toml",
                        "gix-hash/Cargo.toml",
                        "gix-config/Cargo.toml",
                        "gix-config/Cargo.toml",
                        "gix-config/Cargo.toml",
                        "gix-glob/Cargo.toml",
                        "gix-glob/Cargo.toml",
                        "git-protocol/Cargo.toml",
                        "git-config/Cargo.toml",
                        "gix-validate/Cargo.toml",
                        "gix-object/Cargo.toml",
                        "gix/Cargo.toml",
                        Some("failed due to cargo check, RA type inference"),
                        "gix-lock/Cargo.toml",
                        "gix-lock/Cargo.toml",
                        "gix-discover/Cargo.toml",
                        "gix-glob/Cargo.toml",
                        "gix-diff/Cargo.toml",
                    "Cargo.toml",
                    "Cargo.toml",
                    "Cargo.toml",
                    "Cargo.toml",
                    "Cargo.toml",
                    "Cargo.toml",
                    "Cargo.toml",
                    "Cargo.toml",
                    "Cargo.toml",
                    "Cargo.toml",
                        "Cargo.toml",
                        "Cargo.toml",
                        "Cargo.toml",
                        "Cargo.toml",
                "beerus_rest_api/Cargo.toml",
                        "Cargo.toml",
                        "Cargo.toml",
                        "Cargo.toml",
                        "Cargo.toml",
                        "Cargo.toml",
                        "Cargo.toml",
                    "Cargo.toml",
                    "Cargo.toml",
                    "Cargo.toml",
./vendor/rem/src/experiment/src/projects.rs
    pub fix_lifetime_cargo_ms: u128,
    pub cargo_cycles: i32,
pub fn read_cargo_count(stats: &str) -> i32 {
    let mut cmd = Command::new("cargo");
    let path = e.cargo_path.clone().replace("Cargo.toml", "");
        read_cargo_count(stats.as_ref())
    let mut cmd = Command::new("cargo");
        read_cargo_count(stats.as_ref())
    let mut cmd_caller = Command::new("cargo");
    let mut cmd_callee = Command::new("cargo");
        let caller_size_after_ext = read_cargo_count(stats_caller.as_ref());
        let callee_size_after_ext = read_cargo_count(stats_callee.as_ref());
            extraction.cargo_path.as_str(),
        debug!("cargo repair counted: {}", res.repair_count);
        extraction_result.cargo_cycles = res.repair_count;
    let (success, duration) = time_exec("cargo", &mut f);
        extraction_result.failed_at = Some("cargo".to_string())
    extraction_result.fix_lifetime_cargo_ms = duration.as_millis();
        check_project(&extraction.cargo_path, &vec![])
./vendor/rem/src/experiment/src/utils.rs
pub struct CargoError {
        // cargo give rustc error to stdout not stderr
        let stream = deserializer.into_iter::<CargoError>();
                    debug!("error parsing cargo error:\n{}", e);
./vendor/rem/src/rem-repairer/src/common.rs
    Cargo {
        Commands::Cargo {
./vendor/rem/src/rem-repairer/src/main.rs
use home::cargo_home;
pub fn check_project(manifest_path: &str, cargo_args: &Vec<&str>) -> Command {
    let mut check = Command::new("cargo");
    for arg in cargo_args {
pub fn build_project(manifest_path: &str, cargo_args: &Vec<&str>) -> Command {
    let mut check = Command::new("cargo");
    for arg in cargo_args {
        let rustfmt_path = format!("{}/bin/rustfmt", cargo_home().unwrap().to_string_lossy());
./vendor/rem/src/rem-utils/src/lib.rs
    println!("cargo:rustc-env=PROFILE={}", std::env::var("PROFILE").unwrap());
    println!("cargo:rerun-if-changed=build.rs");
./vendor/rust-clippy/build.rs
    /// For internal testing only, ignores the current `publish` settings in the Cargo manifest.
    #[lints(cargo_common_metadata)]
    cargo_ignore_publish: bool = false,
    /// The minimum rust version that the project supports. Defaults to the `rust-version` field in `Cargo.toml`
    // Start looking for a config file in CLIPPY_CONF_DIR, or failing that, CARGO_MANIFEST_DIR.
        .or_else(|| env::var_os("CARGO_MANIFEST_DIR"))
        conf.msrv.read_cargo(sess);
./vendor/rust-clippy/clippy_config/src/conf.rs
        println!("note: you must run `cargo uitest` to update the test results");
./vendor/rust-clippy/clippy_dev/src/deprecate_lint.rs
    let mut cmd = Command::new("cargo");
./vendor/rust-clippy/clippy_dev/src/dogfood.rs
                eprintln!("Formatting check failed!\nRun `cargo dev fmt` to update.");
        "cargo dev fmt",
                eprintln!("Formatting check failed!\nRun `cargo dev fmt` to update.");
// the "main" function of cargo dev fmt
./vendor/rust-clippy/clippy_dev/src/fmt.rs
use crate::utils::{cargo_clippy_path, exit_if_err};
            Command::new(env::var("CARGO").unwrap_or_else(|_| "cargo".into()))
            Command::new(env::var("CARGO").unwrap_or_else(|_| "cargo".into()))
        let status = Command::new(cargo_clippy_path())
./vendor/rust-clippy/clippy_dev/src/lint.rs
            eprintln!("use `cargo bless` to automatically replace `.stderr` and `.fixed` files as tests are being run");
        /// Checks that `cargo dev update_lints` has been run. Used on CI.
    /// Create a new lint and run `cargo dev update_lints`
                "cargo",
    ///     cargo dev lint tests/ui/attrs.rs
    ///     cargo dev lint tests/ui-cargo/wildcard_dependencies/fail {n}
    ///     cargo dev lint ~/my-project
    ///     cargo dev lint ~/my-project -- --fix
    ///     cargo dev lint file.rs -- -W clippy::pedantic {n}
    ///     cargo dev lint ~/my-project -- -- -W clippy::pedantic
        /// Pass extra arguments to cargo/clippy-driver
        /// Remove the dependencies added with 'cargo dev setup intellij'
        /// Remove the pre-commit hook added with 'cargo dev setup git-hook'
    /// `target/.../{clippy-driver,cargo-clippy}`, rebuilds of the project will be reflected in the
        /// Remove the tasks added with 'cargo dev setup vscode-tasks'
    /// Remove the dependencies added with 'cargo dev setup intellij'
    /// Remove the tasks added with 'cargo dev setup vscode-tasks'
    /// Bump the version in the Cargo.toml files
./vendor/rust-clippy/clippy_dev/src/main.rs
    if category == "cargo" && ty.is_none() {
        // `cargo` is a special category, these lints should always be in `clippy_lints/src/cargo`
        ty = Some("cargo");
        write_file(path.join("Cargo.toml"), get_manifest_contents(lint_name, hint))?;
    if lint.category == "cargo" {
        let test_dir = format!("tests/ui-cargo/{}", lint.name);
        "cargo" => assert_eq!(
            lint.category, "cargo",
            "Lints of type `cargo` must have the `cargo` category"
        _ if lint.category == "cargo" => panic!("Lints of category `cargo` must have the `cargo` type"),
./vendor/rust-clippy/clippy_dev/src/new_lint.rs
use crate::utils::{FileUpdater, UpdateStatus, Version, parse_cargo_package};
static CARGO_TOML_FILES: &[&str] = &[
    "clippy_config/Cargo.toml",
    "clippy_lints/Cargo.toml",
    "clippy_utils/Cargo.toml",
    "declare_clippy_lint/Cargo.toml",
    "Cargo.toml",
    for file in CARGO_TOML_FILES {
            let package = parse_cargo_package(src);
./vendor/rust-clippy/clippy_dev/src/release.rs
    println!("note: `cargo uibless` still needs to be run to update the test results");
./vendor/rust-clippy/clippy_dev/src/rename_lint.rs
            Command::new(env::var("CARGO").unwrap_or_else(|_| "cargo".into()))
./vendor/rust-clippy/clippy_dev/src/serve.rs
            println!("info: the hook can be removed with `cargo dev remove git-hook`");
./vendor/rust-clippy/clippy_dev/src/setup/git_hook.rs
    ClippyProjectInfo::new("root", "Cargo.toml", "src/driver.rs"),
    ClippyProjectInfo::new("clippy_lints", "clippy_lints/Cargo.toml", "clippy_lints/src/lib.rs"),
    ClippyProjectInfo::new("clippy_utils", "clippy_utils/Cargo.toml", "clippy_utils/src/lib.rs"),
    cargo_file: &'static str,
    const fn new(name: &'static str, cargo_file: &'static str, lib_rs_file: &'static str) -> Self {
            cargo_file,
    println!("info: the source paths can be removed again with `cargo dev remove intellij`");
    let cargo_content = read_project_file(project.cargo_file)?;
    if inject_deps_into_manifest(rustc_source_dir, project.cargo_file, &cargo_content, &lib_content).is_err() {
            "error: unable to inject dependencies into {} with the Cargo file {}",
            project.name, project.cargo_file
    cargo_toml: &str,
    if cargo_toml.contains(RUSTC_PATH_SECTION) {
        // format the dependencies that are going to be put inside the Cargo.toml
    let new_manifest = cargo_toml.replacen("[dependencies]\n", &all_deps, 1);
    let Ok(mut cargo_content) = read_project_file(project.cargo_file) else {
    let Some(section_start) = cargo_content.find(RUSTC_PATH_SECTION) else {
            project.cargo_file, project.name
    let Some(end_point) = cargo_content.find(DEPENDENCIES_SECTION) else {
            project.cargo_file
    cargo_content.replace_range(section_start..end_point, "");
    match File::create(project.cargo_file) {
            file.write_all(cargo_content.as_bytes()).unwrap();
            println!("info: successfully removed dependencies inside {}", project.cargo_file);
                project.cargo_file, project.name
./vendor/rust-clippy/clippy_dev/src/setup/intellij.rs
                Some("cargo-clippy" | "clippy-driver")
    let status = Command::new("cargo")
    install_bin("cargo-clippy", &dest, standalone, release);
    println!("Created toolchain {name}, use it in other projects with e.g. `cargo +{name} clippy`");
./vendor/rust-clippy/clippy_dev/src/setup/toolchain.rs
            println!("info: the task file can be removed with `cargo dev remove vscode-tasks`");
./vendor/rust-clippy/clippy_dev/src/setup/vscode.rs
const GENERATED_FILE_COMMENT: &str = "// This file was generated by `cargo dev update_lints`.\n\
        "cargo dev update_lints",
        "cargo dev update_lints",
        "cargo dev update_lints",
        "cargo dev update_lints",
        "cargo dev update_lints",
        "cargo dev update_lints",
            "cargo dev update_lints",
            "cargo dev update_lints",
./vendor/rust-clippy/clippy_dev/src/update_lints.rs
static CARGO_CLIPPY_EXE: &str = "cargo-clippy";
static CARGO_CLIPPY_EXE: &str = "cargo-clippy.exe";
/// Returns the path to the `cargo-clippy` binary
pub fn cargo_clippy_path() -> PathBuf {
    path.set_file_name(CARGO_CLIPPY_EXE);
pub struct CargoPackage<'a> {
pub fn parse_cargo_package(s: &str) -> CargoPackage<'_> {
    CargoPackage {
            path.push("Cargo.toml");
                let package = parse_cargo_package(&buf);
./vendor/rust-clippy/clippy_dev/src/utils.rs
    /// into optimization is [cargo-pgo][cargo-pgo].
    /// [cargo-pgo]: https://github.com/Kobzol/cargo-pgo/blob/main/README.md
./vendor/rust-clippy/clippy_lints/src/arbitrary_source_item_ordering.rs
            check_cargo_clippy_attr(cx, attr);
fn check_cargo_clippy_attr(cx: &EarlyContext<'_>, item: &rustc_ast::MetaItem) {
    if item.has_name(sym::feature) && item.value_str() == Some(sym::cargo_clippy) {
            "`feature = \"cargo-clippy\"` was replaced by `clippy`",
./vendor/rust-clippy/clippy_lints/src/attrs/deprecated_cfg_attr.rs
    /// Checks for `#[cfg_attr(feature = "cargo-clippy", ...)]` and for
    /// `#[cfg(feature = "cargo-clippy")]` and suggests to replace it with
    /// #[cfg(feature = "cargo-clippy")]
    "usage of `cfg(feature = \"cargo-clippy\")` instead of `cfg(clippy)`"
./vendor/rust-clippy/clippy_lints/src/attrs/mod.rs
use cargo_metadata::Metadata;
use super::CARGO_COMMON_METADATA;
fn missing_warning(cx: &LateContext<'_>, package: &cargo_metadata::Package, field: &str) {
    span_lint(cx, CARGO_COMMON_METADATA, DUMMY_SP, message);
./vendor/rust-clippy/clippy_lints/src/cargo/common_metadata.rs
use cargo_metadata::Metadata;
./vendor/rust-clippy/clippy_lints/src/cargo/feature_name.rs
struct CargoToml {
                    diag.note("the order of the lints in the table is ignored by Cargo");
    if let Ok(file) = cx.tcx.sess.source_map().load_file(Path::new("Cargo.toml"))
        && let Ok(cargo_toml) = toml::from_str::<CargoToml>(src)
        check_table(cx, cargo_toml.lints.rust, &rustc_groups, &file);
        check_table(cx, cargo_toml.lints.clippy, &clippy_groups, &file);
        check_table(cx, cargo_toml.workspace.lints.rust, &rustc_groups, &file);
        check_table(cx, cargo_toml.workspace.lints.clippy, &clippy_groups, &file);
./vendor/rust-clippy/clippy_lints/src/cargo/lint_groups_priority.rs
use cargo_metadata::MetadataCommand;
    /// `Cargo.toml`. See: https://rust-lang-nursery.github.io/api-guidelines/documentation.html#cargotoml-includes-all-common-metadata-c-metadata
    /// # This `Cargo.toml` is missing a description field:
    /// categories = ["development-tools", "development-tools::cargo-plugins"]
    /// # This `Cargo.toml` includes all common metadata
    /// categories = ["development-tools", "development-tools::cargo-plugins"]
    pub CARGO_COMMON_METADATA,
    cargo,
    "common metadata is defined in `Cargo.toml`"
    /// # The `Cargo.toml` with feature name redundancy
    cargo,
    /// # The `Cargo.toml` with negative feature names
    cargo,
    cargo,
    /// Checks for wildcard dependencies in the `Cargo.toml`.
    /// [As the edition guide says](https://rust-lang-nursery.github.io/edition-guide/rust-2018/cargo-and-crates-io/crates-io-disallows-wildcard-dependencies.html),
    cargo,
    /// Checks for lint groups with the same priority as lints in the `Cargo.toml`
    /// [`[lints]` table](https://doc.rust-lang.org/cargo/reference/manifest.html#the-lints-section).
    /// This lint will be removed once [cargo#12918](https://github.com/rust-lang/cargo/issues/12918)
    "a lint group in `Cargo.toml` at the same priority as a lint"
pub struct Cargo {
impl_lint_pass!(Cargo => [
    CARGO_COMMON_METADATA,
impl Cargo {
            ignore_publish: conf.cargo_ignore_publish,
impl LateLintPass<'_> for Cargo {
            CARGO_COMMON_METADATA,
                        span_lint(cx, lint, DUMMY_SP, format!("could not read cargo metadata: {e}"));
                        span_lint(cx, lint, DUMMY_SP, format!("could not read cargo metadata: {e}"));
./vendor/rust-clippy/clippy_lints/src/cargo/mod.rs
use cargo_metadata::{DependencyKind, Metadata, Node, Package, PackageId};
./vendor/rust-clippy/clippy_lints/src/cargo/multiple_crate_versions.rs
use cargo_metadata::Metadata;
./vendor/rust-clippy/clippy_lints/src/cargo/wildcard_dependencies.rs
// This file was generated by `cargo dev update_lints`.
    crate::cargo::CARGO_COMMON_METADATA_INFO,
    crate::cargo::LINT_GROUPS_PRIORITY_INFO,
    crate::cargo::MULTIPLE_CRATE_VERSIONS_INFO,
    crate::cargo::NEGATIVE_FEATURE_NAMES_INFO,
    crate::cargo::REDUNDANT_FEATURE_NAMES_INFO,
    crate::cargo::WILDCARD_DEPENDENCIES_INFO,
./vendor/rust-clippy/clippy_lints/src/declared_lints.rs
// This file is managed by `cargo dev rename_lint` and `cargo dev deprecate_lint`.
./vendor/rust-clippy/clippy_lints/src/deprecated_lints.rs
    /// surprisingly not be run by `cargo test`. If you really want
./vendor/rust-clippy/clippy_lints/src/doc/mod.rs
mod cargo;
    store.register_late_pass(move |_| Box::new(cargo::Cargo::new(conf)));
./vendor/rust-clippy/clippy_lints/src/lib.rs
    /// Moreover, it clutters the output of `cargo test` since test functions are expanded as
./vendor/rust-clippy/clippy_lints/src/redundant_test_prefix.rs
    /// Running `TESTNAME=ui/my_lint cargo uitest` will produce
./vendor/rust-clippy/clippy_lints/src/utils/author.rs
/// Tracks the current MSRV from `clippy.toml`, `Cargo.toml` or set via `#[clippy::msrv]` in late
    pub fn read_cargo(&mut self, sess: &Session) {
        let cargo_msrv = std::env::var("CARGO_PKG_RUST_VERSION")
        match (self.0, cargo_msrv) {
            (None, Some(cargo_msrv)) => self.0 = Some(cargo_msrv),
            (Some(clippy_msrv), Some(cargo_msrv)) => {
                if clippy_msrv != cargo_msrv {
                        "the MSRV in `clippy.toml` and `Cargo.toml` differ; using `{clippy_msrv}` from `clippy.toml`"
/// Tracks the current MSRV from `clippy.toml`, `Cargo.toml` or set via `#[clippy::msrv]` in early
./vendor/rust-clippy/clippy_utils/src/msrvs.rs
// `cargo dev fmt` ensures that the content of the `generate!()` macro call stays sorted.
    Cargo_toml: "Cargo.toml",
    cargo_clippy: "cargo-clippy",
./vendor/rust-clippy/clippy_utils/src/sym.rs
    cargo: Vec<LintId>,
                Cargo => (None, &mut self.cargo),
        store.register_group(true, "clippy::cargo", Some("clippy_cargo"), self.cargo);
    Cargo,
            Self::Cargo => "cargo",
        cargo,
            Cargo,
./vendor/rust-clippy/declare_clippy_lint/src/lib.rs
    /// Runs cargo clippy --fix and checks if all suggestions apply
./vendor/rust-clippy/lintcheck/src/config.rs
        package_name: env::var("CARGO_PKG_NAME").ok()?,
        version: env::var("CARGO_PKG_VERSION").ok()?,
./vendor/rust-clippy/lintcheck/src/driver.rs
use cargo_metadata::Message;
    env::var("CARGO_TARGET_DIR").unwrap_or_else(|_| "target".to_owned())
/// Represents the actual source code of a crate that we ran "cargo clippy" on
    /// Run `cargo clippy` on the `Crate` and collect and return all the lint warnings that clippy
        let cargo_home = env!("CARGO_HOME");
        // Fallback for other sources, `~/.cargo/...` -> `$CARGO_HOME/...`
        let remap_cargo_home = format!("{cargo_home}=$CARGO_HOME");
        // `~/.cargo/registry/src/index.crates.io-6f17d22bba15001f/crate-2.3.4/src/lib.rs`
        let remap_crates_io = format!("{cargo_home}/registry/src/index.crates.io-6f17d22bba15001f/=");
            &remap_cargo_home,
                "cargo",
            cmd = Command::new("cargo");
            // `cargo clippy` is a wrapper around `cargo check` that mainly sets `RUSTC_WORKSPACE_WRAPPER` to
                .env("CARGO_TARGET_DIR", shared_target_dir("recursive"))
                .expect("failed to run cargo");
            .env("CARGO_TARGET_DIR", shared_target_dir.as_os_str())
            // Roughly equivalent to `cargo clippy`/`cargo clippy --fix`
    mut message: cargo_metadata::diagnostic::Diagnostic,
) -> cargo_metadata::diagnostic::Diagnostic {
    let mut build_cmd = Command::new("cargo");
        build_cmd.env("CARGO_PROFILE_RELEASE_DEBUG", "true");
    // assert that we launch lintcheck from the repo root (via cargo lintcheck)
    if fs::metadata("lintcheck/Cargo.toml").is_err() {
        eprintln!("lintcheck needs to be run from clippy's repo root!\nUse `cargo lintcheck` alternatively.");
                "clippy::cargo",
    Path::new(env!("CARGO_MANIFEST_DIR")).parent().unwrap()
        "./lintcheck/Cargo.toml",
    let status = Command::new("cargo")
./vendor/rust-clippy/lintcheck/src/main.rs
use cargo_metadata::diagnostic::{Diagnostic, DiagnosticSpan};
            || diag.message.contains("could not read cargo metadata")
        // --recursive bypasses cargo so we have to strip the rendered output ourselves
./vendor/rust-clippy/lintcheck/src/output.rs
//! In `--recursive` mode we set the `lintcheck` binary as the `RUSTC_WRAPPER` of `cargo check`,
use cargo_metadata::diagnostic::Diagnostic;
./vendor/rust-clippy/lintcheck/src/recursive.rs
        let major = std::env!("CARGO_PKG_VERSION_MAJOR").parse::<u8>().unwrap();
        let minor = std::env!("CARGO_PKG_VERSION_MINOR").parse::<u8>().unwrap();
        let patch = std::env!("CARGO_PKG_VERSION_PATCH").parse::<u16>().unwrap();
        let crate_name = String::from(std::env!("CARGO_PKG_NAME"));
            "cargo:rustc-env=GIT_HASH={}",
            "cargo:rustc-env=COMMIT_DATE={}",
            "cargo:rustc-env=RUSTC_RELEASE_CHANNEL={}",
// some code taken and adapted from RLS and cargo
        println!("cargo::rerun-if-changed={}", git_head_file.display());
        println!("cargo::rerun-if-changed={}", git_head_ref_file.display());
./vendor/rust-clippy/rustc_tools_util/src/lib.rs
/// Track files that may be accessed at runtime in `file_depinfo` so that cargo will re-run clippy
    // Used by `clippy::cargo` lints and to determine the MSRV. `cargo clippy` executes `clippy-driver`
    // with the current directory set to `CARGO_MANIFEST_DIR` so a relative path is fine
    if Path::new("Cargo.toml").exists() {
        file_depinfo.insert(sym::Cargo_toml);
    // During development track the `clippy-driver` executable so that cargo will re-run clippy whenever
/// This is different from `DefaultCallbacks` that it will inform Cargo to track the value of
        // Setting RUSTC_WRAPPER causes Cargo to pass 'rustc' as the first argument.
        let relevant_package = !no_deps || env::var("CARGO_PRIMARY_PACKAGE").is_ok();
        // Do not run Clippy for Cargo's info queries so that invalid CLIPPY_ARGS are not cached
        // https://github.com/rust-lang/cargo/issues/14385
./vendor/rust-clippy/src/driver.rs
    // Check for version and help flags even when invoked as 'cargo-clippy'
    cargo_subcommand: &'static str,
        let mut cargo_subcommand = "check";
                    cargo_subcommand = "fix";
        if cargo_subcommand == "fix" && !clippy_args.iter().any(|arg| arg == "--no-deps") {
            cargo_subcommand,
        let mut cmd = Command::new(env::var("CARGO").unwrap_or_else(|_| "cargo".into()));
            .arg(self.cargo_subcommand)
        .expect("could not run cargo")
        .expect("failed to wait for cargo?");
    <cyan,bold>cargo clippy</> <cyan>[OPTIONS] [--] [<<ARGS>>...]</>
See all options with <cyan,bold>cargo check --help</>.
To allow or deny a lint from the command line you can use <cyan,bold>cargo clippy --</> with:
    <cyan,bold>--manifest-path</> <cyan><<PATH>></>  Path to Cargo.toml
    <cyan,bold>--frozen</>                Require Cargo.lock and cache are up to date
    <cyan,bold>--locked</>                Require Cargo.lock is up to date
        let args = "cargo clippy --fix".split_whitespace().map(ToString::to_string);
        assert_eq!("fix", cmd.cargo_subcommand);
        let args = "cargo clippy --fix".split_whitespace().map(ToString::to_string);
        let args = "cargo clippy --fix -- --no-deps"
        let args = "cargo clippy".split_whitespace().map(ToString::to_string);
        assert_eq!("check", cmd.cargo_subcommand);
./vendor/rust-clippy/src/main.rs
    let root_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let output = Command::new("cargo")
        "Formatting check failed. Run `cargo dev fmt` to update formatting."
./vendor/rust-clippy/tests/check-fmt.rs
use cargo_metadata::Message;
use cargo_metadata::diagnostic::{Applicability, Diagnostic};
/// dependencies must be added to Cargo.toml at the project root. Test
        help: Try adding to dev-dependencies in Cargo.toml\n\
        let target_dir = PathBuf::from(var_os("CARGO_TARGET_DIR").unwrap_or_else(|| "target".into()));
                "cargo uibless".into()
                    let mut p = CommandBuilder::cargo();
                    // <https://github.com/rust-lang/cargo/issues/4423> we cannot use RUSTFLAGS to
                crate_manifest_path: Path::new("clippy_test_deps").join("Cargo.toml"),
    config.bless_command = Some("cargo uitest --features internal -- -- --bless".into());
fn run_ui_cargo(cx: &TestContext) {
    let mut config = cx.base_config("ui-cargo", false);
    config.program.input_file_flag = CommandBuilder::cargo().input_file_flag;
    config.program.out_dir_flag = CommandBuilder::cargo().out_dir_flag;
        ("CARGO_INCREMENTAL".into(), Some("0".into())),
        "cargo-clippy.exe"
        "cargo-clippy"
        cfg!(target_pointer_width = "32") && path.ends_with("tests/ui-cargo/module_style/fail_mod/Cargo.toml")
            path.ends_with("Cargo.toml")
            "cargo" => run_ui_cargo,
            _ => panic!("unknown speedtest: {speedtest} || accepted speedtests are: [ui, cargo, toml, internal]"),
        run_ui_cargo(&cx);
        ui_cargo_toml_metadata();
fn ui_cargo_toml_metadata() {
    let ui_cargo_path = Path::new("tests/ui-cargo");
    let cargo_common_metadata_path = ui_cargo_path.join("cargo_common_metadata");
        ["fail_publish", "fail_publish_true", "pass_publish_empty"].map(|path| cargo_common_metadata_path.join(path));
    for entry in walkdir::WalkDir::new(ui_cargo_path) {
        if path.file_name() != Some(OsStr::new("Cargo.toml")) {
                || path.starts_with(&cargo_common_metadata_path),
./vendor/rust-clippy/tests/compile-test.rs
This file is generated by `cargo bless --test config-metadata`.
            panic!("`{path}` is out of date, run `cargo bless --test config-metadata` to update it");
            panic!("`{path}` is out of date, run `cargo bless --test config-metadata` to update it");
./vendor/rust-clippy/tests/config-metadata.rs
    let root_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let mut command = Command::new(&*test_utils::CARGO_CLIPPY_PATH);
        .env("CARGO_INCREMENTAL", "0")
./vendor/rust-clippy/tests/dogfood.rs
//! `env INTEGRATION=rust-lang/log cargo test --test integration --features=integration`
const CARGO_CLIPPY: &str = "cargo-clippy";
const CARGO_CLIPPY: &str = "cargo-clippy.exe";
    let root_dir = std::path::PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let clippy_binary = target_dir.join(env!("PROFILE")).join(CARGO_CLIPPY);
        .env("CARGO_TARGET_DIR", target_dir)
./vendor/rust-clippy/tests/integration.rs
    let test_dirs = ["ui", "ui-cargo", "ui-internal", "ui-toml"]
./vendor/rust-clippy/tests/lint_message_convention.rs
pub static CARGO_CLIPPY_PATH: LazyLock<PathBuf> = LazyLock::new(|| {
    path.set_file_name("cargo-clippy");
./vendor/rust-clippy/tests/test_utils/mod.rs
#![warn(clippy::cargo_common_metadata)]
./vendor/rust-clippy/tests/ui-cargo/cargo_common_metadata/fail/src/main.rs
#![warn(clippy::cargo_common_metadata)]
./vendor/rust-clippy/tests/ui-cargo/cargo_common_metadata/fail_publish/src/main.rs
#![warn(clippy::cargo_common_metadata)]
./vendor/rust-clippy/tests/ui-cargo/cargo_common_metadata/fail_publish_true/src/main.rs
#![warn(clippy::cargo_common_metadata)]
./vendor/rust-clippy/tests/ui-cargo/cargo_common_metadata/pass/src/main.rs
#![warn(clippy::cargo_common_metadata)]
./vendor/rust-clippy/tests/ui-cargo/cargo_common_metadata/pass_publish_empty/src/main.rs
#![warn(clippy::cargo_common_metadata)]
./vendor/rust-clippy/tests/ui-cargo/cargo_common_metadata/pass_publish_false/src/main.rs
// FIXME: this should produce a warning, because the attribute says 1.58 and the cargo.toml file
./vendor/rust-clippy/tests/ui-cargo/cargo_rust_version/fail_file_attr/src/main.rs
// FIXME: find a way to add rustflags to ui-cargo tests
./vendor/rust-clippy/tests/ui-cargo/module_style/fail_mod_remap/src/main.rs
    let _ = Symbol::intern("Cargo.toml");
./vendor/rust-clippy/tests/ui-internal/interning_literals.rs
    s.as_str() == "Cargo.toml";
./vendor/rust-clippy/tests/ui-internal/symbol_as_str.rs
#![cfg_attr(feature = "cargo-clippy", doc = "a")]
#[cfg_attr(feature = "cargo-clippy", derive(Debug))]
#[cfg_attr(not(feature = "cargo-clippy"), derive(Debug))]
#[cfg(feature = "cargo-clippy")]
#[cfg(not(feature = "cargo-clippy"))]
#[cfg(any(feature = "cargo-clippy"))]
#[cfg(all(feature = "cargo-clippy"))]
./vendor/rust-clippy/tests/ui/cfg_attr_cargo_clippy.rs
// note: cargo fmt can remove double spaces from normal and block comments
./vendor/rust-clippy/tests/ui/doc/doc_comment_double_space_linebreaks.rs
// This file was generated by `cargo dev update_lints`.
./vendor/rust-clippy/tests/ui/deprecated.rs
    let current_version = env!("CARGO_PKG_VERSION").as_bytes();
./vendor/rust-clippy/tests/ui/string_lit_as_bytes.rs
// This file was generated by `cargo dev update_lints`.
./vendor/rust-clippy/tests/ui/rename.rs
    let clippy_version = read_version("Cargo.toml");
        "clippy_config/Cargo.toml",
        "clippy_lints/Cargo.toml",
        "clippy_utils/Cargo.toml",
        "declare_clippy_lint/Cargo.toml",
./vendor/rust-clippy/tests/versioncheck.rs
use test_utils::{CARGO_CLIPPY_PATH, IS_RUSTC_TEST_SUITE};
    let root = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    Command::new("cargo")
        .env("CARGO_TARGET_DIR", &target_dir)
    let output = Command::new(&*CARGO_CLIPPY_PATH)
        .env("CARGO_INCREMENTAL", "0")
        .env("CARGO_TARGET_DIR", &target_dir)
    let root = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    Command::new("cargo")
        .env("CARGO_TARGET_DIR", &target_dir)
    let output = Command::new(&*CARGO_CLIPPY_PATH)
        .env("CARGO_INCREMENTAL", "0")
        .env("CARGO_TARGET_DIR", &target_dir)
        let output = Command::new(&*CARGO_CLIPPY_PATH)
            .env("CARGO_INCREMENTAL", "0")
            .env("CARGO_TARGET_DIR", &target_dir)
    // Make sure Cargo is aware of the removal of `--no-deps`.
        let output = Command::new(&*CARGO_CLIPPY_PATH)
            .env("CARGO_INCREMENTAL", "0")
            .env("CARGO_TARGET_DIR", &target_dir)
    // Trigger a successful build, so Cargo would like to cache the build result.
    // Make sure Cargo is aware of the new `--cfg` flag.
./vendor/rust-clippy/tests/workspace.rs
#[doc=r#"The source repository as advertised in Cargo.toml."#]
#[doc=r#"The compiler that cargo resolved to use."#]
#[doc=r#"The documentation generator that cargo resolved to use."#]
#[doc=r#"The target architecture, given by `CARGO_CFG_TARGET_ARCH`."#]
#[doc=r#"The endianness, given by `CARGO_CFG_TARGET_ENDIAN`."#]
#[doc=r#"The toolchain-environment, given by `CARGO_CFG_TARGET_ENV`."#]
#[doc=r#"The OS-family, given by `CARGO_CFG_TARGET_FAMILY`."#]
#[doc=r#"The operating system, given by `CARGO_CFG_TARGET_OS`."#]
#[doc=r#"The pointer width, given by `CARGO_CFG_TARGET_POINTER_WIDTH`."#]
./target/debug/build/rav1e-22812799b0c0ccaa/out/built.rs
                "cargo:warning=could not execute `llvm-config` one or more \
                "cargo:warning=could not execute `xcode-select` one or more \
./target/debug/build/clang-sys-f0d249b62f9aa798/out/common.rs
    println!("cargo:rustc-link-search={}", directory.display());
            println!("cargo:rustc-link-search={}", lib.display());
            println!("cargo:rustc-link-search=native={}", out);
        println!("cargo:rustc-link-lib=dylib=libclang");
        println!("cargo:rustc-link-lib=dylib={}", name);
./target/debug/build/clang-sys-f0d249b62f9aa798/out/dynamic.rs
