use serde::{Deserialize, Serialize};
use sha3::{Digest, Sha3_256};
use std::str::FromStr;
use std::fmt;

/// Each chunk, image and file has uid.
///
/// Uid is a 256 bit hash value, generated by sha3-256 hash function and some postprocessing.
/// The most convenient way for users to deal with uid is using `uid_query` function. The user
/// inputs a hex representation of a uid, or a prefix of it, and the function returns
/// matched uids.
///
/// The first 192 bits (128 of `high` + 64 of `low`) are from the hash function, and
/// the remaining bits are for metadata.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub struct Uid {
    pub(crate) high: u128,
    pub(crate) low: u128,
}

#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
pub enum UidType {
    Chunk,
    Image,
    File,
    KnowledgeBase,
    Summary,

    /// It's deprecated.
    Group,
}

#[derive(Clone, Copy, Debug)]
pub enum UidWriteMode {
    Naive,
    Compact,
}

impl Uid {
    const METADATA_MASK: u128 = 0xffff_ffff_ffff_ffff_0000_0000_0000_0000;
    const CHUNK_TYPE: u128 = (0x1 << 32);
    const IMAGE_TYPE: u128 = (0x2 << 32);
    const FILE_TYPE: u128 = (0x3 << 32);
    const GROUP_TYPE: u128 = (0x4 << 32);
    const KNOWLEDGE_BASE_TYPE: u128 = (0x5 << 32);
    const SUMMARY_TYPE: u128 = (0x6 << 32);

    pub(crate) fn decode_partial(bytes: &[u8]) -> Result<Self, String> {
        match bytes.len() {
            0 => Ok(Uid { high: 0, low: 0 }),
            1..=15 => Ok(Uid { high: 0, low: u128_from_bytes(bytes)? }),
            16 => Ok(Uid { high: 0, low: u128_from_bytes(bytes)? }),
            17..=31 => Ok(Uid { high: u128_from_bytes(&bytes[..(bytes.len() - 16)])?, low: u128_from_bytes(&bytes[(bytes.len() - 16)..])? }),
            32 => Ok(Uid { high: u128_from_bytes(&bytes[0..16])?, low: u128_from_bytes(&bytes[16..])? }),
            _ => Err(String::from("Cannot decode Uid")),
        }
    }

    pub(crate) fn encode_partial(&self, len: usize, buffer: &mut Vec<u8>) {
        for b in self.high.to_be_bytes().into_iter().chain(self.low.to_be_bytes().into_iter()).skip(32 - len) {
            buffer.push(b);
        }
    }

    pub fn decode(bytes: &[u8]) -> Result<Self, String> {
        match bytes.len() {
            32 => Ok(Uid { high: u128_from_bytes(&bytes[0..16])?, low: u128_from_bytes(&bytes[16..])? }),
            _ => Err(String::from("Cannot decode Uid")),
        }
    }

    pub fn encode(&self, buffer: &mut Vec<u8>) {
        for b in self.high.to_be_bytes().into_iter().chain(self.low.to_be_bytes().into_iter()) {
            buffer.push(b);
        }
    }

    pub(crate) fn byte_len(&self) -> usize {
        if self.high == 0 {
            (255 - self.low.leading_zeros() as usize) / 8 - 15
        } else {
            (255 - self.high.leading_zeros() as usize) / 8 + 1
        }
    }

    pub fn dummy() -> Self {
        Uid {
            high: 0,
            low: 0,
        }
    }

    pub fn new_image(bytes: &[u8]) -> Self {
        let mut hasher = Sha3_256::new();
        hasher.update(bytes);
        let mut result = format!("{:064x}", hasher.finalize()).parse::<Uid>().unwrap();
        result = result.clear_metadata();
        result.low |= Uid::IMAGE_TYPE;
        result.low |= (bytes.len() as u128) & 0xffff_ffff;
        result
    }

    pub fn new_group(uids: &[Uid]) -> Self {
        let mut result = Uid::dummy();
        let child_count = 0;

        for uid in uids.iter() {
            result += *uid;
        }

        result = result.clear_metadata();
        result.low |= Uid::GROUP_TYPE;
        result.low |= (child_count as u128) & 0xffff_ffff;
        result
    }

    pub fn new_knowledge_base(uids: &[Uid]) -> Self {
        let mut result = Uid::dummy();

        for uid in uids.iter() {
            result += *uid;
        }

        result = result.clear_metadata();
        result.low |= Uid::KNOWLEDGE_BASE_TYPE;
        result.low |= (uids.len() as u128) & 0xffff_ffff;
        result
    }

    pub fn new_summary(summary: &str) -> Self {
        let mut hasher = Sha3_256::new();
        hasher.update(summary.as_bytes());

        let mut result = format!("{:064x}", hasher.finalize()).parse::<Uid>().unwrap();
        result = result.clear_metadata();
        result.low |= Uid::SUMMARY_TYPE;
        result.low |= (summary.len() as u128) & 0xffff_ffff;
        result
    }

    pub fn update_file_uid(mut old: Uid, old_path: &str, new_path: &str) -> Self {
        let mut old_path_hasher = Sha3_256::new();
        old_path_hasher.update(old_path.as_bytes());
        let mut old_path_uid = format!("{:064x}", old_path_hasher.finalize()).parse::<Uid>().unwrap();
        old_path_uid.low &= Uid::METADATA_MASK;
        let mut new_path_hasher = Sha3_256::new();
        new_path_hasher.update(new_path.as_bytes());
        let mut new_path_uid = format!("{:064x}", new_path_hasher.finalize()).parse::<Uid>().unwrap();
        new_path_uid.low &= Uid::METADATA_MASK;

        old ^= old_path_uid;
        old ^= new_path_uid;
        old
    }

    pub(crate) fn from_prefix_and_suffix(prefix: &str, suffix: &str) -> Result<Self, String> {
        if prefix.len() != 2 || suffix.len() != 62 {
            Err(format!("Invalid Uid: {}{}", prefix, suffix))
        }

        else {
            match (suffix.get(0..30), suffix.get(30..)) {
                (Some(high_suff), Some(low)) => match (
                    u128::from_str_radix(&format!("{prefix}{high_suff}"), 16),
                    u128::from_str_radix(low, 16),
                ) {
                    (Ok(high), Ok(low)) => Ok(Uid { high, low }),
                    _ => Err(format!("Invalid Uid: {}{}", prefix, suffix)),
                },
                _ => Err(format!("Invalid Uid: {}{}", prefix, suffix)),
            }
        }
    }

    pub fn get_prefix(&self) -> String {
        format!("{:02x}", self.high >> 120)
    }

    pub fn get_suffix(&self) -> String {
        format!("{:030x}{:032x}", self.high & 0xff_ffff_ffff_ffff_ffff_ffff_ffff_ffff, self.low)
    }

    pub fn get_short_name(&self) -> String {
        format!("{:08x}", self.high >> 96)
    }

    /// It returns the first `n` characters of the uid.
    /// It returns the full uid if `n` is greater than 64.
    pub fn abbrev(&self, n: usize) -> String {
        let s = self.to_string();
        s.get(0..n.min(64)).unwrap().to_string()
    }

    pub fn is_valid_prefix(s: &str) -> bool {
        s.len() <= 64 && s.chars().all(
            |c| match c {
                // `uid_query` does not allow upper case letters!!
                '0'..='9' => true,
                'a'..='f' => true,
                _ => false,
            }
        )
    }

    #[must_use = "method returns a new uid and does not mutate the original value"]
    pub(crate) fn clear_metadata(&self) -> Uid {
        let mut result = *self;
        result.low &= Uid::METADATA_MASK;
        result
    }

    pub(crate) fn get_uid_type(&self) -> Result<UidType, String> {
        let field = ((self.low >> 32) & 0xf) << 32;

        match field {
            Uid::CHUNK_TYPE => Ok(UidType::Chunk),
            Uid::IMAGE_TYPE => Ok(UidType::Image),
            Uid::FILE_TYPE => Ok(UidType::File),
            Uid::GROUP_TYPE => Ok(UidType::Group),
            Uid::KNOWLEDGE_BASE_TYPE => Ok(UidType::KnowledgeBase),
            Uid::SUMMARY_TYPE => Ok(UidType::Summary),
            _ => Err(self.to_string()),
        }
    }

    pub fn get_data_size(&self) -> usize {
        (self.low & 0xffff_ffff) as usize
    }

    fn checked_sub(&self, other: Uid) -> Option<Uid> {
        let (carry, low) = match self.low.checked_sub(other.low) {
            Some(n) => (0, n),
            None => (1, u128::MAX - other.low + self.low + 1),
        };

        if carry > self.high {
            None
        }

        else {
            match (self.high - carry).checked_sub(other.high) {
                Some(high) => Some(Uid { high, low }),
                None => None,
            }
        }
    }
}

impl fmt::Display for Uid {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> Result<(), fmt::Error> {
        write!(fmt, "{:032x}{:032x}", self.high, self.low)
    }
}

impl FromStr for Uid {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, String> {
        if s.len() != 64 {
            Err(s.to_string())
        }

        else {
            match (s.get(0..32), s.get(32..)) {
                (Some(high), Some(low)) => match (
                    u128::from_str_radix(high, 16),
                    u128::from_str_radix(low, 16),
                ) {
                    (Ok(high), Ok(low)) => Ok(Uid { high, low }),
                    _ => Err(s.to_string()),
                },
                _ => Err(s.to_string()),
            }
        }
    }
}

impl std::ops::BitXor for Uid {
    type Output = Self;

    fn bitxor(self, rhs: Self) -> Self {
        Uid {
            low: self.low ^ rhs.low,
            high: self.high ^ rhs.high,
        }
    }
}

impl std::ops::BitXorAssign for Uid {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.low ^= rhs.low;
        self.high ^= rhs.high;
    }
}

impl std::ops::Add for Uid {
    type Output = Self;

    /// It wraps result when there's an overflow.
    fn add(self, rhs: Self) -> Self {
        let (low, carry) = self.low.overflowing_add(rhs.low);
        let mut high = self.high.wrapping_add(rhs.high);

        if carry {
            high = high.wrapping_add(1);
        }

        Uid {
            low,
            high,
        }
    }
}

impl std::ops::AddAssign for Uid {
    fn add_assign(&mut self, rhs: Self) {
        let result = *self + rhs;
        *self = result;
    }
}

fn u128_from_bytes(bytes: &[u8]) -> Result<u128, String> {
    match bytes.len() {
        0 => Ok(0),
        1..=15 => {
            let mut padded = [0; 16];
            padded[(16 - bytes.len())..].copy_from_slice(bytes);
            Ok(u128::from_be_bytes(padded))
        },
        16 => Ok(u128::from_be_bytes(bytes.try_into().unwrap())),
        _ => Err(String::from("Cannot decode u128 from bytes")),
    }
}
