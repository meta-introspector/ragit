use serde::{Deserialize, Serialize};
use sha3::{Digest, Sha3_256};
use std::fmt;
use std::str::FromStr;
use thiserror::Error;

#[derive(Clone, Debug)]
pub struct AuditRecordAt {
    pub path: String,
    pub id: String,
}

#[derive(Error, Debug)]
pub enum UidError {
    #[error("Invalid UID: {0}")]
    InvalidUid(String),
    #[error("Cannot decode u128 from bytes")]
    DecodeError,
    #[error(transparent)]
    Io(#[from] std::io::Error), // Changed from ragit_fs::FileError
    #[error(transparent)]
    Json(#[from] serde_json::Error),
}

/// Each chunk, image and file has uid.
///
/// Uid is a 256 bit hash value, generated by sha3-256 hash function and some postprocessing.
/// The most convenient way for users to deal with uid is using `uid_query` function. The user
/// inputs a hex representation of a uid, or a prefix of it, and the function returns
/// matched uids.
///
/// The first 192 bits (128 of `high` + 64 of `low`) are from the hash function, and
/// the remaining bits are for metadata.
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub struct Uid {
    pub(crate) high: u128,
    pub(crate) low: u128,
}

#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
pub enum UidType {
    Chunk,
    Image,
    File,
    KnowledgeBase,
    Summary,

    /// It's deprecated.
    Group,
}

#[derive(Clone, Copy, Debug)]
pub enum UidWriteMode {
    Naive,
    Compact,
}

impl Uid {
    const METADATA_MASK: u128 = 0xffff_ffff_ffff_ffff_0000_0000_0000_0000;
    const CHUNK_TYPE: u128 = (0x1 << 32);
    const IMAGE_TYPE: u128 = (0x2 << 32);
    const FILE_TYPE: u128 = (0x3 << 32);

    const GROUP_TYPE: u128 = (0x4 << 32);
    const KNOWLEDGE_BASE_TYPE: u128 = (0x5 << 32);
    const SUMMARY_TYPE: u128 = (0x6 << 32);

    pub fn decode_partial(bytes: &[u8]) -> Result<Self, UidError> {
        match bytes.len() {
            0 => Ok(Uid { high: 0, low: 0 }),
            1..=15 => Ok(Uid {
                high: 0,
                low: u128_from_bytes(bytes)?,
            }),
            16 => Ok(Uid {
                high: 0,
                low: u128_from_bytes(bytes)?,
            }),
            17..=31 => Ok(Uid {
                high: u128_from_bytes(&bytes[..(bytes.len() - 16)])?,
                low: u128_from_bytes(&bytes[(bytes.len() - 16)..])?,
            }),
            32 => Ok(Uid {
                high: u128_from_bytes(&bytes[0..16])?,
                low: u128_from_bytes(&bytes[16..])?,
            }),
            _ => Err(UidError::InvalidUid("Cannot decode Uid".to_string())),
        }
    }

    pub fn encode_partial(&self, len: usize, buffer: &mut Vec<u8>) {
        for b in self
            .high
            .to_be_bytes()
            .into_iter()
            .chain(self.low.to_be_bytes().into_iter())
            .skip(32 - len)
        {
            buffer.push(b);
        }
    }

    pub fn decode(bytes: &[u8]) -> Result<Self, UidError> {
        match bytes.len() {
            32 => Ok(Uid {
                high: u128_from_bytes(&bytes[0..16])?,
                low: u128_from_bytes(&bytes[16..])?,
            }),
            _ => Err(UidError::InvalidUid("Cannot decode Uid".to_string())),
        }
    }

    pub fn encode(&self, buffer: &mut Vec<u8>) {
        for b in self
            .high
            .to_be_bytes()
            .into_iter()
            .chain(self.low.to_be_bytes().into_iter())
        {
            buffer.push(b);
        }
    }

    pub fn byte_len(&self) -> usize {
        if self.high == 0 {
            (255 - self.low.leading_zeros() as usize) / 8 - 15
        } else {
            (255 - self.high.leading_zeros() as usize) / 8 + 1
        }
    }

    pub fn dummy() -> Self {
        Uid { high: 0, low: 0 }
    }

    pub fn new_from_u128(n: u128) -> Self {
        Uid { high: 0, low: n }
    }

    pub fn new_from_slice(data: &[u8]) -> Self {
        let mut hasher = Sha3_256::new();
        hasher.update(data);
        let mut result = format!("{:064x}", hasher.finalize())
            .parse::<Uid>()
            .unwrap();
        result = result.clear_metadata();
        result.low |= Uid::CHUNK_TYPE;
        result.low |= (data.len() as u128) & 0xffff_ffff;
        result
    }

    pub fn new_image(bytes: &[u8]) -> Self {
        let mut hasher = Sha3_256::new();
        hasher.update(bytes);
        let mut result = format!("{:064x}", hasher.finalize())
            .parse::<Uid>()
            .unwrap();
        result = result.clear_metadata();
        result.low |= Uid::IMAGE_TYPE;
        result.low |= (bytes.len() as u128) & 0xffff_ffff;
        result
    }

    pub fn new_group(uids: &[Uid]) -> Self {
        let mut result = Uid::dummy();
        let child_count = 0;

        for uid in uids.iter() {
            result += *uid;
        }

        result = result.clear_metadata();
        result.low |= Uid::GROUP_TYPE;
        result.low |= (child_count as u128) & 0xffff_ffff;
        result
    }

    pub fn new_knowledge_base(uids: &[Uid]) -> Self {
        let mut result = Uid::dummy();

        for uid in uids.iter() {
            result += *uid;
        }

        result = result.clear_metadata();
        result.low |= Uid::KNOWLEDGE_BASE_TYPE;
        result.low |= (uids.len() as u128) & 0xffff_ffff;
        result
    }

    pub fn new_summary(summary: &str) -> Self {
        let mut hasher = Sha3_256::new();
        hasher.update(summary.as_bytes());

        let mut result = format!("{:064x}", hasher.finalize())
            .parse::<Uid>()
            .unwrap();
        result = result.clear_metadata();
        result.low |= Uid::SUMMARY_TYPE;
        result.low |= (summary.len() as u128) & 0xffff_ffff;
        result
    }

    // Temporarily commented out due to compilation issues
    /*
    pub fn update_file_uid(mut old: Uid, old_path: &str, new_path: &str) -> Self {
        let mut old_path_hasher = Sha3_256::new();
        old_path_hasher.update(old_path.as_bytes());
        let mut old_path_uid = format!("{:064x}", old_path_hasher.finalize()).parse::<Uid>().unwrap();
        old_path_uid.low &= Uid::METADATA_MASK;
        let mut new_path_hasher = Sha3_256::new();
        new_path_hasher.update(new_path.as_bytes());
        let mut new_path_uid = format!("{:064x}", new_path_hasher.finalize()).parse::<Uid>().unwrap();
        new_path_uid.low &= Uid::METADATA_MASK;

        old ^= old_path_uid;
        old ^= new_path_uid;
        old
    }
    */

    // Temporarily commented out due to compilation issues
    /*
    pub fn from_prefix_and_suffix(prefix: &str, suffix: &str) -> Result<Self, UidError> {
        if prefix.len() != 2 || suffix.len() != 62 {
            Err(UidError::InvalidUid(format!("Invalid Uid: {}{}", prefix, suffix)))
        }

        else {
            match (suffix.get(0..30), suffix.get(30..)) {
                (Some(high_suff), Some(low)) => match (
                    u128::from_str_radix(&format!("{}{}", prefix, high_suff), 16),
                    u128::from_str_radix(low, 16),
                ) {
                    (Ok(high), Ok(low)) => Ok(Uid { high, low }),
                    _ => Err(UidError::InvalidUid(format!("Invalid Uid: {}{}", prefix, suffix))),
                },
                _ => Err(UidError::InvalidUid(format!("Invalid Uid: {}{}", prefix, suffix))),
            }
        }
    }
    */

    pub fn get_prefix(&self) -> String {
        format!("{:02x}", self.high >> 120)
    }

    pub fn get_suffix(&self) -> String {
        format!(
            "{:030x}{:032x}",
            self.high & 0xff_ffff_ffff_ffff_ffff_ffff_ffff_ffff,
            self.low
        )
    }

    pub fn get_short_name(&self) -> String {
        format!("{:08x}", self.high >> 96)
    }

    /// It returns the first `n` characters of the uid.
    /// It returns the full uid if `n` is greater than 64.
    pub fn abbrev(&self, n: usize) -> String {
        let s = self.to_string();
        s.get(0..n.min(64)).unwrap().to_string()
    }

    pub fn is_valid_prefix(s: &str) -> bool {
        s.len() <= 64
            && s.chars().all(|c| match c {
                // `uid_query` does not allow upper case letters!!
                '0'..='9' => true,
                'a'..='f' => true,
                _ => false,
            })
    }

    #[must_use = "method returns a new uid and does not mutate the original value"]
    pub(crate) fn clear_metadata(&self) -> Uid {
        let mut result = *self;
        result.low &= Uid::METADATA_MASK;
        result
    }

    pub fn get_uid_type(&self) -> Result<UidType, UidError> {
        let field = ((self.low >> 32) & 0xf) << 32;

        match field {
            Uid::CHUNK_TYPE => Ok(UidType::Chunk),
            Uid::IMAGE_TYPE => Ok(UidType::Image),
            Uid::FILE_TYPE => Ok(UidType::File),
            Uid::GROUP_TYPE => Ok(UidType::Group),
            Uid::KNOWLEDGE_BASE_TYPE => Ok(UidType::KnowledgeBase),
            Uid::SUMMARY_TYPE => Ok(UidType::Summary),
            _ => Err(UidError::InvalidUid(self.to_string())),
        }
    }

    pub fn get_data_size(&self) -> usize {
        (self.low & 0xffff_ffff) as usize
    }

    pub fn checked_sub(&self, other: Uid) -> Option<Uid> {
        let (carry, low) = match self.low.checked_sub(other.low) {
            Some(n) => (0, n),
            None => (1, u128::MAX - other.low + self.low + 1),
        };

        if carry > self.high {
            None
        } else {
            match (self.high - carry).checked_sub(other.high) {
                Some(high) => Some(Uid { high, low }),
                None => None,
            }
        }
    }
}

impl fmt::Display for Uid {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> Result<(), fmt::Error> {
        write!(fmt, "{:032x}{:032x}", self.high, self.low)
    }
}

impl FromStr for Uid {
    type Err = UidError;

    fn from_str(s: &str) -> Result<Self, UidError> {
        if s.len() != 64 {
            Err(UidError::InvalidUid(s.to_string()))
        } else {
            match (s.get(0..32), s.get(32..)) {
                (Some(high), Some(low)) => match (
                    u128::from_str_radix(high, 16),
                    u128::from_str_radix(low, 16),
                ) {
                    (Ok(high), Ok(low)) => Ok(Uid { high, low }),
                    _ => Err(UidError::InvalidUid(s.to_string())),
                },
                _ => Err(UidError::InvalidUid(s.to_string())),
            }
        }
    }
}

impl std::ops::BitXor for Uid {
    type Output = Self;

    fn bitxor(self, rhs: Self) -> Self {
        Uid {
            low: self.low ^ rhs.low,
            high: self.high ^ rhs.high,
        }
    }
}

impl std::ops::BitXorAssign for Uid {
    fn bitxor_assign(&mut self, rhs: Self) {
        self.low ^= rhs.low;
        self.high ^= rhs.high;
    }
}

impl std::ops::Add for Uid {
    type Output = Self;

    /// It wraps result when there's an overflow.
    fn add(self, rhs: Self) -> Self {
        let (low, carry) = self.low.overflowing_add(rhs.low);
        let mut high = self.high.wrapping_add(rhs.high);

        if carry {
            high = high.wrapping_add(1);
        }

        Uid { low, high }
    }
}

impl std::ops::AddAssign for Uid {
    fn add_assign(&mut self, rhs: Self) {
        let result = *self + rhs;
        *self = result;
    }
}

fn u128_from_bytes(bytes: &[u8]) -> Result<u128, UidError> {
    match bytes.len() {
        0 => Ok(0),
        1..=15 => {
            let mut padded = [0; 16];
            padded[(16 - bytes.len())..].copy_from_slice(bytes);
            Ok(u128::from_be_bytes(padded))
        }
        16 => Ok(u128::from_be_bytes(bytes.try_into().unwrap())),
        _ => Err(UidError::DecodeError),
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct FileSchema {
    pub path: String,
    pub is_processed: bool,
    pub length: u64,
    pub uid: Uid,
    pub chunks: usize,
    pub model: String,
    pub last_updated: u64,
}

impl FileSchema {
    pub fn dummy() -> Self {
        FileSchema {
            path: String::new(),
            is_processed: false,
            length: 0,
            uid: Uid::dummy(),
            chunks: 0,
            model: String::new(),
            last_updated: 0,
        }
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ImageSchema {
    pub uid: Uid,
    pub extracted_text: String,
    pub explanation: String,
    pub size: u64,
    pub bytes: Vec<u8>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct ChunkSchema {
    pub title: String,
    pub summary: String,
}

impl ChunkSchema {
    pub fn dummy(_data: &str, _len: usize) -> Self {
        Self {
            title: String::new(),
            summary: String::new(),
        }
    }

    pub fn empty() -> Self {
        Self {
            title: String::new(),
            summary: String::new(),
        }
    }

    pub fn render(&self) -> String {
        String::new()
    }
}
