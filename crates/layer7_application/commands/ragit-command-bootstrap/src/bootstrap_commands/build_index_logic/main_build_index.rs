use anyhow::Result;
use std::path::PathBuf;
use ragit_index_types::index_struct::Index;
use ragit_memory_monitor::MemoryMonitor;
use crate::bootstrap_commands::build_index_logic::get_staged_files::get_staged_files;
use text_splitter::{TextSplitter, Characters};
use std::fs;
use ragit_types::build_config::BuildConfig;
use ragit_types::fixed_types::fixed_chunk_struct::FixedChunk;
use ragit_types::uid::Uid;
use ragit_types::chunk::chunk_source::ChunkSource;

pub async fn build_index(
    verbose: bool,
    _temp_dir: &PathBuf,
    _actual_root_dir: &PathBuf,
    index: &mut Index,
    _max_iterations: Option<usize>,
    max_memory_gb: Option<u64>,
    memory_monitor: &mut MemoryMonitor,
) -> Result<(), anyhow::Error> {
    if verbose {
        println!("bootstrap_index_self: Running rag build");
        println!("bootstrap_index_self: Before ragit_index_effects::build (placeholder)");
        memory_monitor.capture_and_log_snapshot("Before ragit_index_effects::build");
    }
    memory_monitor.check_memory_limit(max_memory_gb, "Before ragit_index_effects::build")?;

    let _staged_files = get_staged_files(index)?;
    let build_config = BuildConfig::default();
    if verbose { println!("DEBUG: BuildConfig chunk_size: {}", build_config.chunk_size); }
    let splitter = TextSplitter::new(Characters);

    // Simple TextSplitter test case
    let test_content = "This is a test string for the TextSplitter. It should be split into multiple chunks.";
    let test_chunks: Vec<&str> = splitter.chunks(test_content, 10).collect();
    if verbose { println!("DEBUG: Test Content: \"{}"\", test_content); }
    if verbose { println!("DEBUG: Test Chunks generated: {}", test_chunks.len()); }
    for (i, chunk) in test_chunks.iter().enumerate() {
        if verbose { println!("DEBUG: Test Chunk {}: \"{}"\", i, chunk); }
}
    }

    let staged_files_cloned = index.staged_files.clone();

    if verbose {
        println!("bootstrap_index_self: Iterating through staged files for chunking and indexing.");
        println!("DEBUG: Number of staged files: {}", staged_files_cloned.len());
    }
    for file_path_buf in &staged_files_cloned {
        let content = fs::read_to_string(file_path_buf)?;
        if verbose { println!("DEBUG: Content of file {:?}: \n{}", file_path_buf, content); }
        if verbose { println!("DEBUG: Chunk size: {}", build_config.chunk_size); }
        let chunks: Vec<&str> = splitter.chunks(&content).collect();
        if verbose { println!("DEBUG: Number of chunks generated by splitter: {}", chunks.len()); }
        let file_path_str = file_path_buf.to_string_lossy().to_string();
        let mut chunk_index = 0;
        for chunk_data in chunks {
            let new_chunk = FixedChunk {
                data: chunk_data.into(),
                file: file_path_str.clone().into(),
                index: chunk_index,
                uid: Uid::new_from_slice(chunk_data.as_bytes()), // Generate UID from chunk data
                char_len: chunk_data.len(),
                source: ChunkSource::File { path: file_path_str.clone(), index: chunk_index, page: None },
                ..FixedChunk::dummy()
            };
            index.add_chunk(new_chunk);
            chunk_index += 1;
        }
    }
    if verbose { println!("DEBUG: Total chunks added to index: {}", index.chunks.len()); }

    if verbose {
        println!("bootstrap_index_self: After ragit_index_effects::build (placeholder)");
        println!("bootstrap_index_self: Built index (placeholder)");
        memory_monitor.capture_and_log_snapshot("After ragit_index_effects::build");
    }
    memory_monitor.check_memory_limit(max_memory_gb, "After ragit_index_effects::build")?;
    Ok(())
}