use super::schema_parse_error::SchemaParseError;use super::token::{Token, GroupKind};use super::tokenize_state::TokenizeState;pub fn tokenize(s: &[u8], index: &mut usize) -> Result<Vec<Token>, SchemaParseError> {    let mut curr_state = TokenizeState::Init;    let mut result = vec![];    let mut cursor = *index;    loop {        match curr_state {            TokenizeState::Init => match s.get(*index) {                Some(d @ (b'{' | b'(' | b'[')) => {                    *index += 1;                    let inner = tokenize(s, index)?;                    if s.get(*index) == Some(&super::matching_delim::matching_delim(*d)) {                        result.push(Token::Group {                            kind: GroupKind::from(*d),                            tokens: inner,                        });                    } else {                        return Err(SchemaParseError::UnmatchedGroup(*d));                    }                }                Some(b'}' | b')' | b']') => {                    return Ok(result);                }                Some(m @ (b'"' | b'\'')) => {                    curr_state = TokenizeState::Literal(*m);                    cursor = *index + 1;                }                Some(b'0'..=b'9') => {                    curr_state = TokenizeState::Number;                    cursor = *index;                }                Some(b' ' | b'
' | b'' | b'	') => {}                Some(b'a'..=b'z' | b'A'..=b'Z' | b'_' | b'-') => {                    curr_state = TokenizeState::Identifier;                    cursor = *index;                }                Some(p @ (b':' | b',')) => {                    result.push(Token::Punct(*p));                }                Some(c) => {                    return Err(SchemaParseError::UnexpectedByte(*c));                }                None => {                    return Ok(result);                }            },            TokenizeState::Number => match s.get(*index) {                Some(b'0'..=b'9' | b'.') => {}                _ => {                    let ns = String::from_utf8_lossy(&s[cursor..*index]).to_string();                    match ns.parse::<i64>() {                        Ok(n) => {                            curr_state = TokenizeState::Init;                            result.push(Token::Integer(n));                            continue;                        }                        Err(_) => match ns.parse::<f64>() {                            Ok(n) => {                                curr_state = TokenizeState::Init;                                result.push(Token::Float(n));                                continue;                            }                            Err(e) => {                                return Err(SchemaParseError::ParseFloatError(e));                            }                        },                    }                }            },            TokenizeState::Identifier => match s.get(*index) {                Some(b'a'..=b'z' | b'A'..=b'Z' | b'_' | b'-') => {}                _ => match String::from_utf8(s[cursor..*index].to_vec()) {                    Ok(s) => {                        curr_state = TokenizeState::Init;                        result.push(Token::Literal(s));                        continue;                    }                    Err(e) => {                        return Err(SchemaParseError::Utf8Error(e));                    }                },            },            TokenizeState::Literal(marker) => match s.get(*index) {                Some(c) if *c == marker => match String::from_utf8(s[cursor..*index].to_vec()) {                    Ok(s) => {                        curr_state = TokenizeState::Init;                        result.push(Token::Literal(s));                        continue;                    }                    Err(e) => {                        return Err(SchemaParseError::Utf8Error(e));                    }                },                Some(_) => {}                None => {                    return Err(SchemaParseError::UnmatchedGroup(marker));                }            },        }        *index += 1;    }}