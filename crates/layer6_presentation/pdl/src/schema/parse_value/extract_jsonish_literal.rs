use super::SchemaType;use serde_json::Value;use super::jsonish_literal::JsonishLiteral;use super::enums::{NaturalLanguageParseState, JsonParseState, JsonGroup, JsonMatch};pub fn extract_jsonish_literal(s: &'_ str) -> JsonishLiteral<'_> {    let mut state = NaturalLanguageParseState::Init;    let mut json_stack = vec![];    let mut start_index = 0;    let mut result = JsonishLiteral {        s,        integers: vec![],        floats: vec![],        braces: vec![],        brackets: vec![],        likely_to_be_broken_json: false,    };    for (index, c) in s.bytes().enumerate() {        match &mut state {            NaturalLanguageParseState::Init => match c {                b'0'..=b'9' | b'-' => {                    state = NaturalLanguageParseState::Integer;                    start_index = index;                }                b'{' | b'[' => {                    state = NaturalLanguageParseState::Json(JsonParseState::Init);                    json_stack.push(JsonGroup::from(c));                    start_index = index;                }                b'}' | b']' => {                    result.likely_to_be_broken_json = true;                }                _ => {}            },            NaturalLanguageParseState::Integer => match c {                b'0'..=b'9' => {}                b'.' => {                    state = NaturalLanguageParseState::Float;                }                _ => {                    state = NaturalLanguageParseState::Init;                    result.integers.push((start_index, index));                    result.floats.push((start_index, index));                }            },            NaturalLanguageParseState::Float => match c {                b'0'..=b'9' => {}                _ => {                    state = NaturalLanguageParseState::Init;                    result.floats.push((start_index, index));                }            },            // It doesn't have to be a strict json parser. `serde_json` will do that.            NaturalLanguageParseState::Json(json_state) => match json_state {                JsonParseState::Init => match c {                    b'{' | b'[' => {                        json_stack.push(JsonGroup::from(c));                    }                    b'}' | b']' => match json_stack.pop() {                        Some(jsg) => {                            if jsg == JsonGroup::from(c) {                                if json_stack.is_empty() {                                    state = NaturalLanguageParseState::Init;                                    if c == b'}' {                                        result.braces.push((start_index, index + 1));                                    } else {                                        result.brackets.push((start_index, index + 1));                                    }                                }                            } else {                                // There's no point in parsing this json literal any further                                state = NaturalLanguageParseState::Init;                                result.likely_to_be_broken_json = true;                                break;                            }                        }                        None => {                            // There's no point in parsing this json literal any further                            state = NaturalLanguageParseState::Init;                            result.likely_to_be_broken_json = true;                            break;                        }                    },                    b'"' => {                        *json_state = JsonParseState::String { escape: false };                    }                    _ => {}                },                JsonParseState::String { escape } => match (c, &escape) {                    (b'"', false) => {                        *json_state = JsonParseState::Init;                    }                    (b'\', false) => {                        *escape = true;                    }                    (_, false) => {}                    (_, true) => {                        *escape = false;                    }                },            },        }    }    match state {        NaturalLanguageParseState::Init => {}        NaturalLanguageParseState::Integer => {            result.integers.push((start_index, s.len()));            result.floats.push((start_index, s.len()));        }        NaturalLanguageParseState::Float => {            result.floats.push((start_index, s.len()));        }        NaturalLanguageParseState::Json(_) => {            result.likely_to_be_broken_json = true;        }    }    result}