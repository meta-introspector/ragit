use crate::error::Error;use crate::Pdl;use crate::schema::parse::parse_schema;use crate::message::{Message, MessageContent};use crate::role::{Role, PdlRole};use crate::escape_pdl_tokens::escape_pdl_tokens;use crate::unescape_pdl_tokens::unescape_pdl_tokens;use crate::try_parse_inline_block::try_parse_inline_block;pub fn parse_pdl(    s: &str,    context: &tera::Context,    curr_dir: &str,    strict_mode: bool,) -> Result<Pdl, Error> {    let mut renderer = tera::Tera::default();    renderer.autoescape_on(vec!["__tera_one_off"]);    renderer.set_escape_fn(escape_pdl_tokens);    let tera_rendered = match renderer.render_str(s, context) {        Ok(t) => t,        Err(e) => {            if strict_mode {                return Err(e.into());            } else {                s.to_string()            }        }    };    let mut messages = vec![];    let mut schema = None;    let mut curr_role = None;    let mut line_buffer = vec![];    let last_line = "<|assistant|>";    for line in tera_rendered.lines().chain(std::iter::once(last_line)) {        let trimmed = line.trim();        if trimmed.starts_with("<|") && trimmed.ends_with("|>") && trimmed.len() > 4 {            match trimmed                .to_ascii_lowercase()                .get(2..(trimmed.len() - 2))                .unwrap()            {                t @ ("user" | "system" | "assistant" | "schema" | "reasoning") => {                    if !line_buffer.is_empty() || curr_role.is_some() {                        match curr_role {                            Some(PdlRole::Schema) => match parse_schema(&line_buffer.join("\n")) {                                Ok(s) => {                                    if schema.is_some() && strict_mode {                                        return Err(Error::InvalidPdl(String::from(                                            "<|schema|> appeared multiple times.",                                        )));                                    }                                    schema = Some(s);                                }                                Err(e) => {                                    if strict_mode {                                        return Err(e.into());                                    }                                }                            },                            Some(PdlRole::Reasoning) => {}                            _ => {                                let raw_contents = line_buffer.join("\n");                                let raw_contents = raw_contents.trim();                                let role = match curr_role {                                    Some(role) => role,                                    None => {                                        if raw_contents.is_empty() {                                            curr_role = Some(PdlRole::from(t));                                            line_buffer = vec![];                                            continue;                                        }                                        if strict_mode {                                            return Err(Error::RoleMissing);                                        }                                        PdlRole::System                                    }                                };                                match into_message_contents(raw_contents, curr_dir) {                                    Ok(t) => {                                        messages.push(Message {                                            role: role.into(),                                            content: t,                                        });                                    }                                    Err(e) => {                                        if strict_mode {                                            return Err(e);                                        } else {                                            messages.push(Message {                                                role: role.into(),                                                content: vec![MessageContent::String(                                                    raw_contents.to_string(),                                                )],                                            });                                        }                                    }                                }                            }                        }                    }                    curr_role = Some(PdlRole::from(t));                    line_buffer = vec![];                    continue;                }                t => {                    if strict_mode && t.chars().all(|c| c.is_ascii_alphabetic()) {                        return Err(Error::InvalidTurnSeparator(t.to_string()));                    }                    line_buffer.push(line.to_string());                }            }        } else {            line_buffer.push(line.to_string());        }    }    if let Some(Message { content, .. }) = messages.last() {        if content.is_empty() {            messages.pop().unwrap();        }    }    let result = Pdl { schema, messages };    if strict_mode {        result.validate()?;    }    Ok(result)}fn into_message_contents(s: &str, curr_dir: &str) -> Result<Vec<MessageContent>, Error> {    let bytes = s.as_bytes().iter().copied().collect::<Vec<_>>();    let mut index = 0;    let mut result = vec![];    let mut string_buffer = vec![];    loop {        match bytes.get(index) {            Some(b'<') => match try_parse_inline_block(&bytes, index, curr_dir) {                Ok(Some((image_type, bytes, new_index))) => {                    if !string_buffer.is_empty() {                        match String::from_utf8(string_buffer.clone()) {                            Ok(s) => {                                result.push(MessageContent::String(unescape_pdl_tokens(&s)));                            }                            Err(e) => {                                return Err(e.into());                            }                        }                    }                    result.push(MessageContent::Image { image_type: image_type.into(), bytes });                    index = new_index;                    string_buffer = vec![];                    continue;                }                Ok(None) => {                    string_buffer.push(b'<');                }                Err(e) => {                    return Err(e);                }            },            Some(b) => {                string_buffer.push(*b);            }            None => {                if !string_buffer.is_empty() {                    match String::from_utf8(string_buffer) {                        Ok(s) => {                            result.push(MessageContent::String(unescape_pdl_tokens(&s)));                        }                        Err(e) => {                            return Err(e.into());                        }                    }                }                break;            }        }        index += 1;    }    Ok(result)}